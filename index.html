<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procrasti-Nope</title>
    <link rel="icon" type="image/png" href="src/images/icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- SortableJS for Drag and Drop -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    
    <!-- Firebase SDKs (Updated Version) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            onAuthStateChanged, 
            GoogleAuthProvider, 
            signInWithPopup, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut,
            reauthenticateWithCredential,
            EmailAuthProvider,
            updatePassword,
            updateEmail,
            fetchSignInMethodsForEmail,
            deleteUser
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc,
            writeBatch,
            onSnapshot,
            collection,
            query,
            where,
            getDocs,
            updateDoc,
            arrayUnion,
            arrayRemove,
            deleteDoc
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Expose Firebase functions to the global scope to be used in the main script
        window.firebaseSDK = {
            initializeApp,
            getAuth,
            onAuthStateChanged,
            GoogleAuthProvider,
            signInWithPopup,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            reauthenticateWithCredential,
            EmailAuthProvider,
            updatePassword,
            updateEmail,
            fetchSignInMethodsForEmail,
            deleteUser,
            getFirestore,
            doc,
            getDoc,
            setDoc,
            writeBatch,
            onSnapshot,
            collection,
            query,
            where,
            getDocs,
            updateDoc,
            arrayUnion,
            arrayRemove,
            deleteDoc
        };
    </script>
    
    <!-- FIX: Pre-emptive theme application to prevent flash of wrong theme -->
    <script>
        (function() {
            try {
                // Check local storage first (for guests)
                const guestData = localStorage.getItem('anonymousUserData');
                const storedSettings = guestData ? JSON.parse(guestData).settings : null;
                
                // If no guest data, check for a simpler theme setting (for logged-in users)
                const themeSetting = storedSettings ? storedSettings.theme : localStorage.getItem('userTheme');
                
                if (themeSetting) {
                    const isDark = themeSetting === 'dark' || (themeSetting === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);
                    if (isDark) {
                        document.documentElement.classList.add('dark-mode');
                    }
                }
            } catch (e) {
                console.error('Error applying initial theme:', e);
            }
        })();
    </script>
    <style>
        /*
        ==========================================================================
        NEOBRUTALIST THEME & VARIABLES (REVAMPED)
        ==========================================================================
        */
        :root {
            --font-main: 'Inter', sans-serif;

            /* Light Theme - WARM & PASTEL */
            --bg-light: #FFF8E7; /* Soft Cream */
            --text-light: #4E443A; /* Warm Dark Brown */
            --border-light: #4E443A;
            --shadow-light: #4E443A;
            --surface-light: #FFFFFF;
            --text-on-accent: #4E443A; /* Dark text for light pastels */
            --surface-light-rgb: 255, 255, 255;

            /* Dark Theme - DEEPER & WARM (MODIFIED) */
            --bg-dark: #211B14; /* Warmer, less dark background */
            --text-dark: #EAE2D6; /* Warm Off-white */
            --border-dark: #EAE2D6;
            --shadow-dark: #655e5e;
            --surface-dark: #352D25; /* Warmer, lighter surface */
            --surface-dark-rgb: 53, 45, 37;
            
            /* Light Theme Accent Colors */
            --accent-pink-light: #FFB7C5;
            --accent-blue-light: #99CCFF;
            --accent-green-light: #A7D4A8;
            --accent-orange-light: #FFB347;
            --accent-purple-light: #C7A2F4;
            --accent-yellow-light: #FFEE93;
            --accent-cyan-light: #A4DDED;
            --accent-red-light: #FF6961;
            --accent-lime-light: #D4E99E;
            --accent-indigo-light: #A5ADFF;
            --accent-teal-light: #87D7C8;
            --accent-amber-light: #FFCF8B;

            /* Base Accent Colors (default to light) */
            --accent-pink: var(--accent-pink-light);
            --accent-blue: var(--accent-blue-light);
            --accent-green: var(--accent-green-light);
            --accent-orange: var(--accent-orange-light);
            --accent-purple: var(--accent-purple-light);
            --accent-yellow: var(--accent-yellow-light);
            --accent-cyan: var(--accent-cyan-light);
            --accent-red: var(--accent-red-light);
            --accent-lime: var(--accent-lime-light);
            --accent-indigo: var(--accent-indigo-light);
            --accent-teal: var(--accent-teal-light);
            --accent-amber: var(--accent-amber-light);

            /* Default State (Light) */
            --bg: var(--bg-light);
            --text: var(--text-light);
            --border: var(--border-light);
            --shadow: var(--shadow-light);
            --surface: var(--surface-light);
            --accent: var(--accent-red);
            --shadow-color: var(--shadow);
            --noise-opacity: 0.05;
            --surface-rgb: var(--surface-light-rgb);


            /* Universal Settings */
            --border-width: 3px;
            --shadow-offset: 6px;
            --radius: 12px;
            --transition-speed: 0.2s;
        }

        .dark-mode {
            --bg: var(--bg-dark);
            --text: var(--text-dark);
            --border: var(--border-dark);
            --shadow: var(--shadow-dark);
            --surface: var(--surface-dark);
            --text-on-accent: var(--text-dark); /* Use light text for pastels in dark mode */
            --noise-opacity: 0.08;
            --surface-rgb: var(--surface-dark-rgb);
            
            /* Dark Theme Accent Colors (Darker, more pastel) */
            --accent-pink-dark: #C98B96;
            --accent-blue-dark: #8A9EC4;
            --accent-green-dark: #8DAF8E;
            --accent-orange-dark: #D99A5B;
            --accent-purple-dark: #A991C4;
            --accent-yellow-dark: #CEC592;
            --accent-cyan-dark: #93B2BC;
            --accent-red-dark: #D97C75;
            --accent-lime-dark: #B4C290;
            --accent-indigo-dark: #9A9FDA;
            --accent-teal-dark: #7DAAA1;
            --accent-amber-dark: #D9B383;

            /* Remap Base Accent Colors to Dark Versions */
            --accent-pink: var(--accent-pink-dark);
            --accent-blue: var(--accent-blue-dark);
            --accent-green: var(--accent-green-dark);
            --accent-orange: var(--accent-orange-dark);
            --accent-purple: var(--accent-purple-dark);
            --accent-yellow: var(--accent-yellow-dark);
            --accent-cyan: var(--accent-cyan-dark);
            --accent-red: var(--accent-red-dark);
            --accent-lime: var(--accent-lime-dark);
            --accent-indigo: var(--accent-indigo-dark);
            --accent-teal: var(--accent-teal-dark);
            --accent-amber: var(--accent-amber-dark);
        }

        /*
        ==========================================================================
        BASE & LAYOUT
        ==========================================================================
        */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            /* Custom Scrollbar Styles */
            scrollbar-width: thin;
            scrollbar-color: var(--accent) var(--surface);
            /* FIX: Prevent layout shift when modals open/close */
            scrollbar-gutter: stable;
        }

        body {
            min-height: 100vh; /* FIX: Allow body to grow with content */
        }
        
        body::-webkit-scrollbar {
            width: 14px;
        }

        body::-webkit-scrollbar-track {
            background: var(--surface);
            border-left: var(--border-width) solid var(--border);
        }

        body::-webkit-scrollbar-thumb {
            background-color: var(--accent);
            border-radius: var(--radius);
            border: var(--border-width) solid var(--border);
        }

        body::before {
            content: '';
            display: block;
            height: 10px;
            background-color: var(--accent);
            transition: background-color var(--transition-speed) ease;
        }
        
        /* Grainy Texture Overlay */
        body::after {
            content: "";
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MDAgNTAwIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuOCIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIvPjwvZmlsdGVyPjxyZWN0IHdpZHRoPSIxMDAl" height="100%" filter="url(#noise)"/></svg>');
            background-size: 250px 250px;
            opacity: var(--noise-opacity);
            pointer-events: none;
            z-index: 10000;
            transition: opacity var(--transition-speed) ease;
            animation: grain 8s steps(10) infinite;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg);
            color: var(--text);
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            overflow-x: hidden;
        }
        
        #app-wrapper {
            transition: filter 0.3s ease-in-out;
        }

        #app-wrapper.blur-background {
            filter: blur(5px);
            pointer-events: none;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem; /* FIX: Reduced padding to minimize gap */
        }
        
        /* IMPORT: Added padding for the bottom nav bar on mobile */
        main.container {
            padding-bottom: 100px;
        }


        .quests-layout {
            display: flex;
            flex-direction: column; /* Default: stack quests vertically */
        }
        
        /* On mobile, quest sections are toggled, not side-by-side */
        @media (max-width: 1023px) {
            .task-group {
                display: none; /* Hide all sections by default */
            }
            .task-group.mobile-visible {
                display: block; /* Show only the active one */
            }
        }

        /* For wider screens, display quests side-by-side */
        @media (min-width: 1024px) {
            .container {
                max-width: 1280px; /* Widen the container */
            }

            .quests-layout {
                flex-direction: row; /* Place items in a row */
                gap: 2rem; /* Add space between the two columns */
                align-items: flex-start; /* Align columns to the top */
            }

            .quests-layout > .task-group {
                flex: 1 1 0px; /* Allow each column to grow and take up equal space */
                margin-bottom: 0; /* Remove bottom margin as 'gap' handles spacing */
            }

            /* Hover effects for action buttons on desktop */
            .task-buttons-wrapper,
            .main-quest-group-header .group-actions {
                opacity: 0;
                transition: opacity var(--transition-speed) ease;
                pointer-events: none;
            }

            .task-item:hover .task-buttons-wrapper,
            .main-quest-group:hover .main-quest-group-header .group-actions,
            .task-item.timer-active .task-buttons-wrapper {
                opacity: 1;
                pointer-events: auto;
            }

            /* FIX: Allow completed quest text to wrap correctly on wide screens */
            .task-item.daily-completed .task-content {
                flex-grow: 1; /* Let the content area grow to fill space */
                margin-right: 0;
            }
        }
        
        /*
        ==========================================================================
        LOADING ANIMATION
        ==========================================================================
        */
        #loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease;
        }

        .loader-box {
            width: 60px;
            height: 60px;
            background-color: var(--surface);
            border: var(--border-width) solid var(--border);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
            animation: spin 1.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg) scale(1); border-radius: 0; }
            50% { transform: rotate(180deg) scale(0.8); border-radius: 50%; }
            100% { transform: rotate(360deg) scale(1); border-radius: 0; }
        }
        
        /*
        ==========================================================================
        LANDING PAGE
        ==========================================================================
        */
        #landing-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .landing-container {
            width: 100%;
            max-width: 450px;
            background-color: var(--surface);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow-color);
            padding: 2.5rem 2rem;
            text-align: center;
        }

        .landing-buttons {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .landing-buttons .btn {
            width: 100%;
            padding: 1rem;
            font-size: 1.2rem;
        }
        #landing-back-btn {
            margin-top: 1.5rem;
        }


        /*
        ==========================================================================
        HEADER & PROGRESS
        ==========================================================================
        */
        .sticky-header {
            position: sticky;
            top: 0;
            background-color: var(--bg);
            padding: 1.5rem 1rem;
            z-index: 10;
            border-bottom: var(--border-width) solid var(--border);
            box-shadow: 0 var(--shadow-offset) 0 var(--shadow);
            margin-bottom: 0; /* Adjusted */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-content {
            text-align: left;
            flex-grow: 1; /* Allow content to take available space */
            min-width: 0; /* Critical for preventing overflow on flex items */
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        #user-display {
            font-weight: 700;
        }
        
        .main-title {
            font-size: 2.5rem;
            font-weight: 900;
            letter-spacing: -2px;
            margin-bottom: 0.25rem;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            color: var(--accent);
            display: inline-block; /* FIX: Shrink hitbox to content */
        }
        .main-title:hover {
            transform: rotate(-1deg) scale(1.02); /* FIX: Tone down animation */
        }


        .quote {
            font-size: 1rem;
            font-weight: 700;
            font-style: italic;
            opacity: 0.8;
        }
        
        .player-progress-section {
            background-color: var(--surface);
            border-bottom: var(--border-width) solid var(--border);
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0; /* FIX: Removed space to reduce gap */
        }
        
        .level-display {
            background-color: var(--accent);
            color: var(--text-on-accent);
            font-weight: 900;
            padding: 0.5rem 1rem;
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .level-display.level-up {
            animation: levelUpPulse 0.5s ease-in-out;
        }
        
        .xp-bar-container {
            flex-grow: 1;
            background-color: var(--bg);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            padding: 0.25rem;
            position: relative;
        }
        
        .xp-bar {
            width: 0%;
            height: 25px;
            background-color: var(--accent);
            border-radius: calc(var(--radius) / 2);
            transition: width 0.5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        #xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 700;
            color: var(--text);
            mix-blend-mode: difference;
            filter: invert(1) grayscale(1);
        }
        .dark-mode #xp-text {
            mix-blend-mode: normal; /* Changed from unset */
            filter: none; /* Changed from unset */
            color: var(--text-dark); /* Explicitly set color for dark mode */
        }
        
        /* Mobile Responsiveness for Header */
        @media (max-width: 640px) {
            .sticky-header {
                padding: 1rem;
                gap: 1rem;
            }
            .main-title {
                font-size: 1.8rem;
                letter-spacing: -1px;
            }
            .quote {
                display: none; /* Hide quote on small screens to save space */
            }
            .theme-btn span {
                display: none;
            }
            .theme-btn {
                padding: 0.75rem; /* Make it a square */
            }
        }
        
        /*
        ==========================================================================
        FRIENDS FEATURE & MOBILE NAV
        ==========================================================================
        */
        /* IMPORT: Desktop friends button */
        #friends-btn-desktop {
            display: none; /* Hidden on mobile by default */
        }
        @media (min-width: 1024px) {
            #friends-btn-desktop {
                display: flex; /* Visible on desktop */
                gap: 0.5rem;
                --shadow-color: var(--shadow);
            }
            #friends-btn-desktop svg {
                width: 20px;
                height: 20px;
            }
        }
        
        /* IMPORT: Mobile bottom navigation bar */
        #mobile-nav {
            display: none; /* Hidden on desktop */
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background-color: var(--surface);
            border-top: var(--border-width) solid var(--border);
            box-shadow: 0px -6px 0 var(--shadow);
            z-index: 500;
            border-top-left-radius: var(--radius);
            border-top-right-radius: var(--radius);
            padding: 0 1rem;
            border-left: var(--border-width) solid var(--border);
            border-right: var(--border-width) solid var(--border);
        }
        .mobile-nav-content {
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 100%;
            border: var(--border-width) dashed rgba(var(--surface-rgb), 0.2);
            border-bottom: none;
            border-radius: calc(var(--radius) - var(--border-width));
            padding-bottom: 5px;
            transform: translateY(2px);
        }
        .mobile-nav-btn {
            background-color: var(--surface);
            border: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-family: var(--font-main);
            font-weight: 700;
            color: var(--text);
            opacity: 0.6;
            transition: all var(--transition-speed) ease;
            padding: 0.5rem;
            border-radius: var(--radius);
            border: var(--border-width) solid transparent;
            box-shadow: 4px 4px 0 transparent;
            flex: 1 1 0px;
        }
        .mobile-nav-btn span {
            font-weight: 900;
        }

        .mobile-nav-btn.active {
            opacity: 1;
            border-color: var(--border);
            box-shadow: 4px 4px 0 var(--shadow);
            transform: translateY(-5px);
            color: var(--accent);
            background-color: var(--bg);
        }

        .mobile-nav-btn.active svg {
            color: var(--accent);
        }
        
        .mobile-nav-btn svg {
            width: 28px;
            height: 28px;
            stroke: currentColor;
            stroke-width: var(--border-width);
        }
        @media (max-width: 1023px) {
            #mobile-nav {
                display: block; /* Show on mobile */
            }
        }
        
        /* IMPORT: Friends Modal */
        #friends-modal .modal-content {
            position: relative;
            overflow: hidden; /* To contain the animated background */
        }

        #friends-modal-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
            overflow: hidden;
        }
        
        #friends-modal-bg svg {
            width: 200%;
            height: 200%;
            animation: bg-pan 40s linear infinite;
        }
        
        @keyframes bg-pan {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-20%, 10%); }
            50% { transform: translate(0, -20%); }
            75% { transform: translate(10%, 10%); }
            100% { transform: translate(0, 0); }
        }
        
        /* NEW: Set min-height to prevent modal resizing between tabs */
        #friends-modal .tab-content {
            min-height: 250px;
        }

        #friends-modal h3 {
            font-weight: 900; /* Bolder headers */
        }
        
        .friends-list-container, .friend-requests-container {
            max-height: 300px;
            overflow-y: auto;
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            padding: 0.5rem;
            background-color: var(--surface);
        }
        
        .friend-item, .friend-request-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border-radius: calc(var(--radius) / 2);
            gap: 0.75rem; /* Add gap for level display */
        }

        /* NEW: Bolder font for friend names */
        .friend-item .friend-name, 
        .friend-request-item span {
            font-weight: 700;
            flex-grow: 1; /* Allow name to take space */
        }


        .friend-item:not(:last-child), .friend-request-item:not(:last-child) {
            border-bottom: var(--border-width) dashed var(--border);
        }

        .friend-item-actions, .friend-request-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }

        /* NEW: Friend Level Display Box */
        .friend-level-display {
            background-color: var(--accent);
            color: var(--text-on-accent);
            font-weight: 900;
            padding: 0.25rem 0.75rem;
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            box-shadow: 4px 4px 0 var(--shadow);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }
        
        
        /* NEW: Neobrutalism styling for friend action buttons */
        .friend-item-actions .remove-friend-btn,
        .friend-request-actions .decline-request-btn {
            --shadow-color: var(--accent-red);
        }
        .friend-request-actions .accept-request-btn {
            --shadow-color: var(--accent-green);
        }

        #add-friend-form {
            display: flex;
            gap: 0.5rem;
        }
        
        #search-username-input { flex-grow: 1; }
        
        .friend-status-message {
            margin-top: 1rem;
            font-weight: 700;
            text-align: center;
            min-height: 1.2em;
        }


        /*
        ==========================================================================
        TASK LIST & ITEMS
        ==========================================================================
        */
        .task-group {
            margin-bottom: 3rem;
        }

        .task-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: var(--border-width) solid var(--border);
        }
        
        .task-group-header .header-actions {
            display: flex;
            gap: 0.5rem;
        }

        .task-group-header h2 {
            font-size: 1.8rem;
            font-weight: 900;
        }

        .main-quest-group, .task-item {
            cursor: grab;
        }
        
        .sortable-ghost {
            opacity: 0.4;
            background-color: var(--accent);
        }
        
        /* Shake animation for all items during drag */
        body.is-dragging .task-item,
        body.is-dragging .main-quest-group {
            animation: shake-light 0.4s cubic-bezier(.36,.07,.19,.97) both infinite;
        }


        .main-quest-group {
            margin-bottom: 1.5rem; /* FIX: Reduced spacing */
            transition: all var(--transition-speed) ease;
        }
        
        .main-quest-group.removing {
             animation: slideOut 0.4s ease forwards;
        }

        .main-quest-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: var(--surface);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow-color);
            position: relative;
            cursor: pointer;
        }

        .group-title-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-grow: 1;
        }

        .expand-icon {
            transition: transform 0.2s ease;
            flex-shrink: 0;
            width: 28px; /* FIX: Increased icon size */
            height: 28px; /* FIX: Increased icon size */
        }

        .main-quest-group.expanded .expand-icon {
            transform: rotate(90deg);
        }

        /* Emphasis for group headers */
        .main-quest-group-header::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: var(--border-width) dashed var(--border);
            border-radius: calc(var(--radius) * 0.5);
            opacity: 0.5;
            pointer-events: none; /* Fix: Allow clicks to pass through the overlay */
        }

        .main-quest-group-header h3 {
            font-size: 1.3rem;
            font-weight: 900;
        }

        .main-quest-group-header .group-actions {
            display: flex;
            gap: 0.5rem;
        }


        #daily-task-list, #standalone-task-list, .main-quest-group ul {
            list-style: none;
        }
        
        /* FIX: Remove space from empty standalone quest list */
        #standalone-task-list:empty {
            display: none;
        }

        .main-quest-group ul.task-list-group {
            min-height: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out, margin-top 0.2s ease-out;
            margin-top: 0;
            padding: 0;
        }

        .main-quest-group:hover ul.task-list-group,
        .main-quest-group.expanded ul.task-list-group {
            max-height: 1000px; /* Increased max-height for very long lists */
            margin-top: 1rem;
            transition: max-height 0.25s ease-in;
            /* FIX: Add padding to prevent shadow clipping on child elements */
            padding-right: 0.5rem;
            padding-bottom: 0.5rem;
        }


        .task-item {
            display: flex;
            flex-wrap: wrap; 
            align-items: center;
            background-color: var(--surface);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow-color);
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            transition: all var(--transition-speed) ease, max-height var(--transition-speed) ease;
            position: relative;
            overflow: hidden;
            max-height: 100px; /* Base height for transitions */
        }
        
        /* Standalone quests look like group headers */
        .task-item.standalone-quest {
             padding: 1rem;
        }
         .task-item.standalone-quest::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: var(--border-width) dashed var(--border);
            border-radius: calc(var(--radius) * 0.5);
            opacity: 0.5;
            pointer-events: none; /* Fix: Allow clicks to pass through the overlay */
        }
         .task-item.standalone-quest .task-text {
            font-size: 1.3rem;
            font-weight: 900;
        }

        .task-item.overdue {
            animation: shake 0.8s cubic-bezier(.36,.07,.19,.97) infinite both;
            border-color: var(--accent-red);
            --shadow-color: var(--accent-red);
        }
        
        /* NEW: Style for when a timer finishes */
        .task-item.timer-finished {
            border-color: var(--accent-red);
            --shadow-color: var(--accent-red);
            animation: shake 0.7s cubic-bezier(.36,.07,.19,.97) 3; /* Shake 3 times and stop */
        }

        .task-item.daily-completed {
            max-height: 50px;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            opacity: 0.6;
            filter: grayscale(0.5);
            cursor: pointer; /* To indicate it's clickable for undo */
        }
        .task-item.daily-completed .task-text {
            text-decoration: line-through;
        }
        
        .task-item.daily-completed .task-buttons-wrapper {
            display: none;
        }

        /* Weekly goal met style */
        .task-item.weekly-goal-met {
            border-style: dashed;
            opacity: 0.8;
        }
        .task-item.weekly-goal-met::after {
            content: 'GOAL MET!';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-10deg);
            font-size: 2rem;
            font-weight: 900;
            color: var(--accent);
            opacity: 0.1;
            pointer-events: none;
        }
        
        /* Hide edit/delete when timer is active on any screen size */
        .task-item.timer-active .task-actions {
            display: none;
        }

        /* Add/Remove Animation */
        .task-item.adding {
            animation: slideIn 0.4s ease forwards;
        }

        .task-item.removing {
            animation: slideOut 0.4s ease forwards;
        }

        /* Completion Animation */
        .task-item.completed {
            animation: celebrate 0.8s ease-in-out forwards;
        }
        
        .task-item .task-content {
             display: flex;
             align-items: center;
             flex-grow: 1;
             flex-basis: 0; /* Important for flex wrapping */
             margin-right: 1rem;
             min-width: 0; /* ADDED: Prevents long text from pushing controls */
        }

        .task-item .task-text {
            font-size: 1.1rem;
            font-weight: 700;
            outline: none;
            transition: all var(--transition-speed) ease;
            padding-bottom: 5px; 
            margin-right: 1rem;
            word-break: break-word; /* Ensure long text wraps */
        }
        
        .task-buttons-wrapper {
            display: flex;
            gap: 0.5rem;
            margin-left: auto;
            align-items: center;
        }

        .task-item .task-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .streak-counter {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-weight: 700;
            margin-right: 1rem;
            color: var(--accent-orange);
        }

        .streak-counter svg {
            width: 20px;
            height: 20px;
        }
        
        /* NEW: Weekly Goal Tag Styling */
        .weekly-goal-tag {
            background-color: var(--accent);
            color: var(--text-on-accent);
            font-weight: 700;
            font-size: 0.8rem;
            padding: 0.25rem 0.75rem;
            border-radius: var(--radius);
            border: var(--border-width) solid var(--border);
            box-shadow: 4px 4px 0 var(--shadow);
            flex-shrink: 0; /* Prevent from shrinking */
        }

        /*
        ==========================================================================
        TIMER CLOCK BUTTON
        ==========================================================================
        */
        .timer-clock-btn {
            position: relative;
        }

        .timer-clock-btn .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px; /* Slightly larger than icon */
            height: 32px;
        }

        .timer-clock-btn .progress-ring-circle {
            transition: stroke-dashoffset 0.5s linear;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            stroke: var(--accent);
            stroke-width: 3;
            fill: transparent;
        }
        
        /*
        ==========================================================================
        BUTTONS & CONTROLS
        ==========================================================================
        */
        .btn {
            background-color: var(--surface);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            font-family: var(--font-main);
            font-weight: 700;
            font-size: 1rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            --shadow-color: var(--accent); /* Buttons get accent colored shadows */
            box-shadow: 4px 4px 0 var(--shadow-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text);
        }
        
        .btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0 var(--shadow-color);
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow-color);
        }
        
        #settings-btn {
            background-color: var(--surface);
             --shadow-color: var(--shadow);
        }


        .btn.icon-btn {
            padding: 0.5rem;
            aspect-ratio: 1 / 1;
        }
        
        .btn.icon-btn svg {
            width: 24px;
            height: 24px;
            stroke: var(--text);
            stroke-width: var(--border-width);
            transition: transform 0.2s ease;
        }
        
        .btn.icon-btn:hover svg:not(.progress-ring) {
            transform: scale(1.1) rotate(5deg);
        }
        
        .complete-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: var(--border-width) solid var(--border);
            cursor: pointer;
            flex-shrink: 0;
            margin-right: 1rem;
            transition: all var(--transition-speed) ease;
            position: relative;
            background-color: var(--surface);
        }
        
        .complete-btn:hover {
            transform: scale(1.1);
        }
        
        .complete-btn.checked {
            background-color: var(--accent);
            border-color: var(--accent);
        }
        
        .complete-btn.checked::after {
            content: 'âœ”';
            color: var(--text-on-accent);
            font-weight: 900;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .task-item.daily-completed .complete-btn {
            pointer-events: none;
        }

        /*
        ==========================================================================
        MOBILE-SPECIFIC TASK INTERACTIONS
        ==========================================================================
        */
        @media (max-width: 1023px) {
            /* On mobile, action buttons are hidden until tap */
            .task-buttons-wrapper {
                opacity: 0;
                pointer-events: none;
                
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                justify-content: center;
                align-items: center;
                
                background-color: rgba(var(--surface-rgb), 0.7);
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px);
                z-index: 5;
                transition: opacity var(--transition-speed) ease;
                /* FIX: Add border radius to match parent container */
                border-radius: calc(var(--radius) - var(--border-width));
            }

            /* When a task is tapped, show the action buttons */
            .task-item.actions-visible .task-buttons-wrapper {
                opacity: 1;
                pointer-events: auto;
            }
            
            /* And blur the content behind the overlay */
            .task-item.actions-visible .task-content,
            .task-item.actions-visible .complete-btn {
                filter: blur(3px);
                transition: filter var(--transition-speed) ease;
                pointer-events: none; /* Prevent clicking blurred items */
            }
            
            /* EXCEPTION: If a timer is active, keep its button visible and not part of the overlay */
            .task-item.timer-active .task-buttons-wrapper {
                opacity: 1 !important;
                pointer-events: auto !important;
                position: static;
                width: auto;
                height: auto;
                background: transparent;
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
                z-index: auto;
                margin-left: auto;
                border-radius: 0; /* Reset radius for this case */
            }
            
            /* NEW: Group Header Mobile Actions */
            .main-quest-group-header.actions-visible .group-actions {
                opacity: 1;
                pointer-events: auto;
            }
            .main-quest-group-header.actions-visible .group-title-container {
                filter: blur(3px);
                transition: filter var(--transition-speed) ease;
                pointer-events: none;
            }
        }
        
        /*
        ==========================================================================
        MODALS & PANELS (ADD TASK, SETTINGS)
        ==========================================================================
        */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-speed) ease, visibility 0s var(--transition-speed);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }
        
        .modal-content {
            background-color: var(--bg);
            border: var(--border-width) solid var(--border);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow-color);
            border-radius: var(--radius);
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            transform: scale(0.9) rotate(-3deg);
            transition: transform var(--transition-speed) cubic-bezier(0.34, 1.56, 0.64, 1);
            max-height: 90vh;
            overflow-y: auto;
        }

        #account-modal .modal-content, #username-modal .modal-content, #manage-account-modal .modal-content {
            max-width: 400px;
            padding: 1.5rem;
        }
        
        .modal-overlay.visible .modal-content {
            transform: scale(1) rotate(0deg);
        }
        
        .modal-content h2 {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            font-weight: 900;
        }
        
        #new-task-input, #new-group-input, .form-group input, #edit-task-input, #new-username-input, #search-username-input {
            width: 100%;
            font-family: var(--font-main);
            font-size: 1.1rem;
            padding: 1rem;
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            background: var(--surface);
            color: var(--text);
        }
        .form-group {
             margin-bottom: 1rem;
        }

        #new-task-input:focus, #new-group-input:focus, .form-group input:focus, #edit-task-input:focus, #new-username-input:focus, #search-username-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 var(--border-width) var(--accent);
        }
        
        #weekly-goal-container, #edit-weekly-goal-container {
            margin-top: 1rem;
            border-top: var(--border-width) dashed var(--border);
            padding-top: 1rem;
        }
        
        #weekly-goal-container label, #edit-weekly-goal-container label {
            font-weight: 700;
            margin-bottom: 1rem; /* Increased space for slider */
            display: block;
        }


        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .modal-submit-btn {
            background-color: var(--accent);
            color: var(--text-on-accent);
            --shadow-color: var(--shadow);
        }
        
        .settings-group {
            margin-bottom: 2rem;
        }
        
        .settings-group h3 {
            font-weight: 900;
            font-size: 1.1rem;
            border-bottom: var(--border-width) solid var(--border);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            display: block;
        }
        
        .settings-group .data-actions,
        .settings-group .account-actions {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .theme-options {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .color-options {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            background-color: rgba(0,0,0,0.04);
            padding: 0.75rem;
            border-radius: var(--radius);
            border: var(--border-width) solid var(--border);
        }

        .dark-mode .color-options {
            background-color: rgba(255,255,255,0.04);
        }
        
        .theme-btn {
            gap: 0.5rem;
            --shadow-color: var(--shadow); /* Use normal shadow color */
        }
        .theme-btn svg {
             width: 20px;
             height: 20px;
             stroke-width: var(--border-width);
        }

        .theme-btn.selected {
            background-color: var(--accent);
            color: var(--text-on-accent);
        }
        .theme-btn.selected svg {
            stroke: var(--text-on-accent);
        }
        
        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: var(--border-width) solid var(--border);
            cursor: pointer;
            transition: transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            box-shadow: 0 0 0 var(--border-width) var(--border);
            transform: scale(1.1);
        }
        
        /* Volume and Timer Slider Styles */
        .volume-slider-container, .timer-slider-container, .weekly-goal-slider-container {
            padding-top: 0.5rem;
        }
        .timer-slider-container {
            margin-bottom: 1.5rem;
        }
        .timer-slider-container label {
            font-weight: 700;
            margin-bottom: 0.75rem;
            display: block;
        }
        #timer-duration-display {
            background: var(--surface);
            padding: 0.25rem 0.5rem;
            border-radius: calc(var(--radius) / 2);
            border: var(--border-width) solid var(--border);
        }

        .timer-unit-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .timer-unit-btn {
            --shadow-color: var(--shadow);
            font-size: 0.9rem;
            padding: 0.5rem 0.75rem;
        }
        .timer-unit-btn.selected {
            background-color: var(--accent);
            color: var(--text-on-accent);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            background-color: var(--surface);
            border: var(--border-width) solid var(--border);
            border-radius: 50%;
            margin-top: -5px; /* Vertically center thumb for new track height */
            box-shadow: 4px 4px 0 var(--shadow);
            transition: all var(--transition-speed) ease;
        }
        input[type="range"]::-moz-range-thumb {
            height: 24px;
            width: 24px;
            background-color: var(--surface);
            border: var(--border-width) solid var(--border);
            border-radius: 50%;
            box-shadow: 4px 4px 0 var(--shadow);
            transition: all var(--transition-speed) ease;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow);
        }
        input[type="range"]:active::-moz-range-thumb {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow);
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 16px;
            background: var(--accent);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
        }
        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 16px;
            background: var(--accent);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
        }
        
        /* Account Modal Specific Styles */
        .form-toggle {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }
        .toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-size: 1rem;
            font-weight: 700;
            text-align: center;
            cursor: pointer;
            background-color: var(--surface);
            border: none;
            color: var(--text);
            transition: all var(--transition-speed) ease;
        }
        .toggle-btn.active {
            background-color: var(--accent);
            color: var(--text-on-accent);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }

        /* FIX: Neobrutalism for Auth forms */
        .auth-form .form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }
        .auth-form .form-group label {
            display: block;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        
        /* IMPORT: Hide tab content that is not active */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        .form-divider {
            text-align: center;
            margin: 1.5rem 0;
            font-weight: 700;
            color: var(--text);
            opacity: 0.7;
        }
        
        .google-btn-custom {
            background-color: #4285F4;
            color: white;
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            font-family: var(--font-main);
            font-weight: 700;
            font-size: 1rem;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            box-shadow: 4px 4px 0 var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            width: 100%;
        }
        .google-btn-custom:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0 var(--shadow);
        }
        .google-btn-custom:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow);
        }
        .dark-mode .google-btn-custom {
            border-color: var(--border-dark);
            box-shadow: 4px 4px 0 var(--shadow-dark);
        }
        .dark-mode .google-btn-custom:hover {
            box-shadow: 6px 6px 0 var(--shadow-dark);
        }
        .dark-mode .google-btn-custom:active {
            box-shadow: 2px 2px 0 var(--shadow-dark);
        }
        .google-btn-custom svg {
            width: 20px;
            height: 20px;
        }
        
        .error-message, .success-message {
            font-weight: 700;
            text-align: center;
            margin-top: 1rem;
            min-height: 1.2em;
            padding: 0 0.5rem;
            line-height: 1.4;
        }

        .error-message {
            color: var(--accent-red-light);
        }
        .success-message {
            color: var(--accent-green-light);
        }
        
        /*
        ==========================================================================
        CONFETTI & CELEBRATIONS
        ==========================================================================
        */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            /* FIX: Use an animation that fades out instead of coming from the top */
            /* animation: confetti-fall 2s ease-out forwards; */
        }
        
        .party-time-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 9999;
            background: linear-gradient(-45deg, var(--accent-pink), var(--accent-blue), var(--accent-green), var(--accent-purple));
            background-size: 400% 400%;
            animation: party-bg 3s ease infinite, fade-out-party 1s 4s forwards;
            opacity: 0.3;
        }

        @keyframes party-bg {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes fade-out-party {
            to { opacity: 0; }
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(150px) rotate(360deg);
                opacity: 0;
            }
        }
        
        /*
        ==========================================================================
        ANIMATIONS
        ==========================================================================
        */
        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -10%); }
            20% { transform: translate(-15%, 5%); }
            30% { transform: translate(7%, -25%); }
            40% { transform: translate(-5%, 25%); }
            50% { transform: translate(-15%, 10%); }
            60% { transform: translate(15%, 0%); }
            70% { transform: translate(0%, 15%); }
            80% { transform: translate(3%, 35%); }
            90% { transform: translate(-10%, 10%); }
        }
        
        @keyframes shake { /* Overdue shake */
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-3px, 0, 0); }
            40%, 60% { transform: translate3d(3px, 0, 0); }
        }
        @keyframes shake-light { /* Dragging shake */
             0% { transform: rotate(0deg); }
             25% { transform: rotate(0.5deg); }
             50% { transform: rotate(0eg); }
             75% { transform: rotate(-0.5deg); }
             100% { transform: rotate(0deg); }
        }

        @keyframes levelUpPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2) rotate(-5deg); box-shadow: 0 0 25px var(--accent); }
            100% { transform: scale(1); }
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
                max-height: 0;
                margin-bottom: 0;
                padding-top: 0;
                padding-bottom: 0;
            }
            to {
                opacity: 1;
                transform: translateY(0);
                max-height: 100px; /* Base height */
                margin-bottom: 1.5rem;
                padding-top: 1rem;
                padding-bottom: 1rem;
            }
        }

        @keyframes slideOut {
            from {
                opacity: 1;
                transform: translateX(0);
                max-height: 100px;
            }
            to {
                opacity: 0;
                transform: translateX(20px);
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
                margin-bottom: 0;
            }
        }
        
        @keyframes celebrate {
            0% { transform: scale(1); }
            20% { transform: scale(1.05) rotate(2deg); background-color: var(--accent); box-shadow: 0 0 20px var(--accent); }
            40% { transform: scale(0.95) rotate(-2deg); }
            60% { transform: scale(1.02); }
            100% {
                transform: translateX(100px) scale(0.5);
                opacity: 0;
                max-height: 0;
                padding: 0;
                margin-bottom: 0;
                border-width: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Initial Loader -->
    <div id="loader-overlay">
        <div class="loader-box"></div>
    </div>

    <!-- Landing Page for first-time users (hidden by default) -->
    <div id="landing-page" style="display: none;">
        <div class="landing-container">
            <!-- Initial choices -->
            <div id="landing-choices">
                <h1 class="main-title" style="margin-bottom: 2rem;">Procrasti-Nope</h1>
                <div class="landing-buttons">
                    <button id="landing-login-btn" class="btn">Login / Sign Up</button>
                    <button id="landing-guest-btn" class="btn">Continue as Guest</button>
                </div>
            </div>
            <!-- Auth form container -->
            <div id="landing-auth-container" style="display: none;">
                <!-- Content is dynamically filled from the #account-modal-content template -->
            </div>
        </div>
    </div>


    <div id="app-wrapper" style="display: none;">
        <header class="sticky-header">
            <div class="header-content">
                <h1 class="main-title">Procrasti-Nope</h1>
                <p class="quote" id="quote-of-the-day">Loading a dose of motivation...</p>
            </div>
            <div class="header-controls">
                <!-- IMPORT: Friends button for desktop -->
                <button id="friends-btn-desktop" class="btn" aria-label="Open Friends Menu">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                    <span>Friends</span>
                </button>
                <button id="settings-btn" class="btn icon-btn" aria-label="Open Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </button>
            </div>
        </header>

        <section class="player-progress-section">
            <div class="level-display">LVL <span id="player-level">1</span></div>
            <div class="xp-bar-container">
                <div id="xp-bar" class="xp-bar"></div>
                <span id="xp-text">0 / 100 XP</span>
            </div>
        </section>

        <main class="container">
            <div class="quests-layout">
                <!-- IMPORT: Added data-section attribute and mobile-visible class -->
                <section class="task-group mobile-visible" data-section="daily">
                    <header class="task-group-header">
                        <h2>Daily Quests</h2>
                        <button class="btn add-task-trigger-btn" data-list="daily" aria-label="Add Daily Quest">+</button>
                    </header>
                    <ul id="daily-task-list"></ul>
                    <div id="no-daily-tasks-message" style="display: none; text-align: center; padding: 2rem; opacity: 0.7;">
                        <p>No daily quests yet. Add one to start your day!</p>
                    </div>
                </section>
                <!-- IMPORT: Added data-section attribute -->
                <section class="task-group" data-section="main">
                    <header class="task-group-header">
                        <h2>Main Quests</h2>
                        <div class="header-actions">
                            <button id="add-standalone-task-btn" class="btn" aria-label="Add Quest">Add Quest</button>
                            <button id="add-group-btn" class="btn" aria-label="Add Group">Add Group</button>
                        </div>
                    </header>
                    <ul id="standalone-task-list"></ul>
                    <div id="general-task-list-container"></div>
                    <div id="no-general-tasks-message" style="display: none; text-align: center; padding: 2rem; opacity: 0.7;">
                        <p>No main quests on your list. Create a group or add a quest to get started!</p>
                    </div>
                </section>
            </div>
        </main>
    </div>
    
    <!-- IMPORT: Mobile Navigation Bar (Moved outside app-wrapper) -->
    <nav id="mobile-nav">
        <div class="mobile-nav-content">
            <button class="mobile-nav-btn active" data-section="daily" aria-label="Daily Quests">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linejoin="round"><path d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2z"></path></svg>
                <span>Daily</span>
            </button>
            <button class="mobile-nav-btn" data-section="main" aria-label="Main Quests">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon></svg>
                <span>Main</span>
            </button>
            <button class="mobile-nav-btn" data-section="friends" aria-label="Friends">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                <span>Friends</span>
            </button>
        </div>
    </nav>

    <!-- Modals -->
    <div id="add-task-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="add-task-modal-title">Add New Quest</h2>
            <form id="add-task-form">
                <input type="text" id="new-task-input" placeholder="e.g., Conquer the world..." required maxlength="30">
                <div id="weekly-goal-container" style="display: none;">
                    <label for="new-task-weekly-goal-slider">Weekly Goal: <span id="new-task-weekly-goal-display">None</span></label>
                    <div class="weekly-goal-slider-container">
                         <input type="range" id="new-task-weekly-goal-slider" min="0" max="7" value="0">
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn" data-close-modal="add-task-modal">Cancel</button>
                    <button type="submit" class="btn modal-submit-btn">Add</button>
                </div>
            </form>
        </div>
    </div>

    <div id="edit-task-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="edit-task-modal-title">Edit Quest</h2>
            <form id="edit-task-form">
                <input type="hidden" id="edit-task-id">
                <input type="text" id="edit-task-input" required maxlength="30">
                <div id="edit-weekly-goal-container" style="display: none;">
                    <label for="edit-task-weekly-goal-slider">Weekly Goal: <span id="edit-task-weekly-goal-display">3</span> days</label>
                    <div class="weekly-goal-slider-container">
                        <input type="range" id="edit-task-weekly-goal-slider" min="0" max="7" value="3">
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn" data-close-modal="edit-task-modal">Cancel</button>
                    <button type="submit" class="btn modal-submit-btn">Save Changes</button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="add-group-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Create New Group</h2>
            <form id="add-group-form">
                <input type="text" id="new-group-input" placeholder="e.g., Project Overlord" required maxlength="30">
                <div class="modal-actions">
                    <button type="button" class="btn" data-close-modal="add-group-modal">Cancel</button>
                    <button type="submit" class="btn modal-submit-btn">Create</button>
                </div>
            </form>
        </div>
    </div>

    <div id="timer-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Set Task Timer</h2>
            <form id="timer-form">
                <div class="timer-slider-container">
                    <label for="timer-duration-slider">Duration: <span id="timer-duration-display">25</span></label>
                    <input type="range" id="timer-duration-slider" min="1" max="100" value="25">
                </div>
                <div class="timer-unit-selector">
                    <button type="button" class="btn timer-unit-btn" data-unit="seconds">Seconds</button>
                    <button type="button" class="btn timer-unit-btn selected" data-unit="minutes">Minutes</button>
                    <button type="button" class="btn timer-unit-btn" data-unit="hours">Hours</button>
                    <button type="button" class="btn timer-unit-btn" data-unit="days">Days</button>
                    <button type="button" class="btn timer-unit-btn" data-unit="weeks">Weeks</button>
                    <button type="button" class="btn timer-unit-btn" data-unit="months">Months</button>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn" data-close-modal="timer-modal">Cancel</button>
                    <button type="submit" class="btn modal-submit-btn">Start Timer</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- IMPORT: Friends Modal -->
    <div id="friends-modal" class="modal-overlay">
        <div class="modal-content">
            <div id="friends-modal-bg">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 800"><defs><filter id="f" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur in="SourceGraphic" stdDeviation="40"></feGaussianBlur></filter></defs><g filter="url(#f)"><circle cx="400" cy="400" r="150" fill="var(--accent-blue)"></circle><circle cx="100" cy="200" r="100" fill="var(--accent-green)"></circle><circle cx="600" cy="150" r="120" fill="var(--accent-red)"></circle><circle cx="700" cy="650" r="180" fill="var(--accent-yellow)"></circle><circle cx="200" cy="700" r="90" fill="var(--accent-purple)"></circle></g></svg>
            </div>
            <div class="form-toggle">
                <button class="toggle-btn active" data-tab="my-friends">Friends</button>
                <button class="toggle-btn" data-tab="requests">Requests <span id="friend-request-count"></span></button>
                <button class="toggle-btn" data-tab="add-friend">Add</button>
            </div>
            
            <div id="my-friends-tab" class="tab-content active">
                <h3>My Friends</h3>
                <div class="friends-list-container">
                    <!-- Friend items will be injected here -->
                </div>
            </div>
            
            <div id="requests-tab" class="tab-content">
                <h3>Friend Requests</h3>
                <div class="friend-requests-container">
                    <!-- Friend request items will be injected here -->
                </div>
            </div>

            <div id="add-friend-tab" class="tab-content">
                 <h3>Add Friend by Username</h3>
                 <form id="add-friend-form">
                    <input type="text" id="search-username-input" placeholder="Enter username..." required>
                    <button type="submit" class="btn icon-btn" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></button>
                 </form>
                 <p class="friend-status-message"></p>
            </div>
            
            <div class="modal-actions"><button class="btn" data-close-modal="friends-modal">Close</button></div>
        </div>
    </div>


    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Settings</h2>
            <div class="settings-group">
                <h3>Account</h3>
                <div class="account-actions">
                    <span id="user-display" style="display: none; align-items:center;"></span>
                    <button id="settings-login-btn" class="btn">Login / Sign Up</button>
                    <button id="manage-account-btn" class="btn" style="display: none;">Manage Account</button>
                    <button id="logout-btn" class="btn" style="display: none;">Logout</button>
                </div>
            </div>
            <div class="settings-group">
                <h3>Theme</h3>
                <div class="theme-options" id="theme-options-buttons">
                    <button class="btn theme-btn" data-theme="light" aria-label="Light Theme"><svg class="sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg><span>Light</span></button>
                    <button class="btn theme-btn" data-theme="dark" aria-label="Dark Theme"><svg class="moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><span>Dark</span></button>
                    <button class="btn theme-btn" data-theme="system" aria-label="System Theme"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line></svg><span>System</span></button>
                </div>
            </div>
            <div class="settings-group">
                <h3>Accent Color</h3>
                <div class="color-options" id="color-options">
                    <div class="color-swatch" data-color="var(--accent-red)" style="background-color: var(--accent-red);"></div><div class="color-swatch" data-color="var(--accent-orange)" style="background-color: var(--accent-orange);"></div><div class="color-swatch" data-color="var(--accent-amber)" style="background-color: var(--accent-amber);"></div><div class="color-swatch" data-color="var(--accent-yellow)" style="background-color: var(--accent-yellow);"></div><div class="color-swatch" data-color="var(--accent-lime)" style="background-color: var(--accent-lime);"></div><div class="color-swatch" data-color="var(--accent-green)" style="background-color: var(--accent-green);"></div><div class="color-swatch" data-color="var(--accent-teal)" style="background-color: var(--accent-teal);"></div><div class="color-swatch" data-color="var(--accent-cyan)" style="background-color: var(--accent-cyan);"></div><div class="color-swatch" data-color="var(--accent-blue)" style="background-color: var(--accent-blue);"></div><div class="color-swatch" data-color="var(--accent-indigo)" style="background-color: var(--accent-indigo);"></div><div class="color-swatch" data-color="var(--accent-purple)" style="background-color: var(--accent-purple);"></div><div class="color-swatch" data-color="var(--accent-pink)" style="background-color: var(--accent-pink);"></div>
                </div>
            </div>
            <div class="settings-group">
                <h3>Sound Volume</h3>
                <div class="volume-slider-container"><input type="range" id="volume-slider" min="0" max="1" step="0.01" aria-label="Volume"></div>
            </div>
             <div class="settings-group">
                <h3 id="data-management-heading">Data (Local)</h3>
                <div class="data-actions">
                    <button id="export-data-btn" class="btn">Export Guest Data</button>
                    <button id="import-data-btn" class="btn">Import Guest Data</button>
                    <input type="file" id="import-file-input" style="display: none;" accept=".json">
                    <button id="reset-progress-btn" class="btn">Reset Progress</button>
                </div>
            </div>
            <div class="modal-actions"><button class="btn" data-close-modal="settings-modal">Close</button></div>
        </div>
    </div>
    
    <div id="account-modal" class="modal-overlay">
        <div class="modal-content"></div>
    </div>
    
    <div id="manage-account-modal" class="modal-overlay">
        <div class="modal-content">
            <div id="reauth-container">
                <h2>Confirm Password</h2>
                <p style="margin-bottom: 1.5rem;">For your security, please enter your password to continue.</p>
                <form id="reauth-form" class="auth-form">
                    <div class="form-group">
                        <label for="reauth-password">Current Password</label>
                        <input type="password" id="reauth-password" required>
                    </div>
                    <button type="submit" class="btn modal-submit-btn" style="width: 100%;">Confirm</button>
                    <p class="error-message" id="reauth-error"></p>
                </form>
            </div>

            <div id="manage-forms-container" style="display: none;">
                <h2>Manage Account</h2>
                
                <form id="update-username-form" class="auth-form" style="margin-top: 2rem;">
                     <div class="settings-group">
                        <h3>Change Username</h3>
                        <p style="margin-bottom: 1rem; font-size: 0.9em; opacity: 0.8;">Changing your username will also update how you log in.</p>
                        <div class="form-group">
                            <label for="update-username-input">New Username</label>
                            <input type="text" id="update-username-input" required minlength="3" maxlength="15">
                        </div>
                        <button type="submit" class="btn modal-submit-btn">Update Username</button>
                        <p class="error-message" id="update-username-error"></p>
                        <p class="success-message" id="update-username-success"></p>
                    </div>
                </form>

                <form id="update-email-form" class="auth-form" style="margin-top: 2rem;">
                     <div class="settings-group">
                        <h3>Change Email</h3>
                         <p style="margin-bottom: 1rem; font-size: 0.9em; opacity: 0.8;">You will be asked to confirm your current password again.</p>
                        <div class="form-group">
                            <label for="update-email-password">Current Password</label>
                            <input type="password" id="update-email-password" required>
                        </div>
                        <div class="form-group">
                            <label for="update-email-input">New Email</label>
                            <input type="email" id="update-email-input" required>
                        </div>
                        <button type="submit" class="btn modal-submit-btn">Update Email</button>
                        <p class="error-message" id="update-email-error"></p>
                        <p class="success-message" id="update-email-success"></p>
                    </div>
                </form>

                <form id="update-password-form" class="auth-form" style="margin-top: 2rem;">
                    <div class="settings-group">
                        <h3>Change Password</h3>
                        <div class="form-group">
                            <label for="update-password-input">New Password</label>
                            <input type="password" id="update-password-input" required>
                        </div>
                        <button type="submit" class="btn modal-submit-btn">Update Password</button>
                        <p class="error-message" id="update-password-error"></p>
                        <p class="success-message" id="update-password-success"></p>
                    </div>
                </form>
                
                <div class="settings-group">
                    <h3>Delete Account</h3>
                    <p style="margin-bottom: 1rem; font-size: 0.9em; opacity: 0.8;">This is permanent and cannot be undone. All your data will be erased.</p>
                    <button type="button" id="delete-account-btn" class="btn" style="width: 100%; background-color: var(--accent-red); color: var(--text-on-accent); --shadow-color: var(--shadow-dark);">Delete My Account</button>
                </div>
            </div>
            <div class="modal-actions">
                 <button type="button" class="btn" data-close-modal="manage-account-modal">Close</button>
            </div>
        </div>
    </div>
    
    <div id="google-signin-loader-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 300px; text-align: center;">
            <h2 style="font-size: 1.5rem;">Connecting...</h2>
            <div class="loader-box" style="margin: 2rem auto;"></div>
            <p>Please complete the sign-in in the popup window.</p>
        </div>
    </div>

    <div id="username-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Choose your Username</h2>
            <p style="margin-bottom: 1.5rem;">This will be your unique name. It cannot be changed later!</p>
            <form id="username-form">
                <input type="text" id="new-username-input" placeholder="e.g., QuestMaster" required minlength="3" maxlength="15">
                <p class="error-message username-error"></p>
                <div class="modal-actions" style="justify-content: flex-end;">
                    <button type="submit" class="btn modal-submit-btn">Save Username</button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="timer-menu-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 350px;">
            <h2>Active Timer</h2><p style="margin-bottom: 1.5rem;">This quest has a timer running.</p>
            <div class="modal-actions" style="justify-content: space-around;">
                <button type="button" id="timer-menu-cancel-btn" class="btn">Cancel Timer</button>
                <button type="button" class="btn" data-close-modal="timer-menu-modal">Leave</button>
            </div>
        </div>
    </div>

    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="confirm-title">Are you sure?</h2>
            <p id="confirm-text" style="margin-bottom: 1.5rem;">This action cannot be undone.</p>
            <div class="modal-actions">
                <button type="button" id="confirm-cancel-btn" class="btn">Cancel</button>
                <button type="submit" id="confirm-action-btn" class="btn modal-submit-btn">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Template for Auth Forms -->
    <template id="account-modal-content">
        <div class="form-toggle">
            <button class="toggle-btn active" data-tab="signup">Sign Up</button>
            <button class="toggle-btn" data-tab="login">Login</button>
        </div>
        <form class="auth-form" data-form="signup">
            <div class="form-group"><label for="signup-username">Username</label><input type="text" class="signup-username" required minlength="3" maxlength="15"></div>
            <div class="form-group"><label for="signup-email">Email</label><input type="email" class="signup-email" required></div>
            <div class="form-group"><label for="signup-password">Password</label><input type="password" class="signup-password" required></div>
            <button type="submit" class="btn modal-submit-btn" style="width: 100%;">Create Account</button>
            <p class="error-message signup-error"></p>
        </form>
        <form class="auth-form" data-form="login" style="display: none;">
             <div class="form-group"><label for="login-email">Email or Username</label><input type="text" class="login-email" required></div>
             <div class="form-group"><label for="login-password">Password</label><input type="password" class="login-password" required></div>
             <button type="submit" class="btn modal-submit-btn" style="width: 100%;">Login</button>
             <p class="error-message login-error"></p>
             <div class="form-divider">OR</div>
             <div class="google-signin-btn-container"></div>
        </form>
    </template>

    <script type="module">
        // --- NOTE ON SECURITY ---
        // All client-side code (like this script) is visible in the browser.
        // Your Firebase config is meant to be public. True security is enforced 
        // by your Firestore Security Rules in the Firebase console, not by hiding code.
        
        // --- FIREBASE SETUP ---
        const firebaseConfig = {
            apiKey: "AIzaSyAOKGyzZ984TpHBrrgpOvlHKFJlDngGOSM",
            authDomain: "procrastinope.firebaseapp.com",
            projectId: "procrastinope",
            storageBucket: "procrastinope.appspot.com",
            messagingSenderId: "513129540063",
            appId: "1:513129540063:web:5fa30d80d41aa121bffc6a",
            measurementId: "G-5PJTMZFS2C"
        };

        let app, auth, db;
        let currentUser = null;
        let unsubscribeFromFirestore = null;
        let unsubscribeFromFriends = null;
        let appController = null;
        
        // --- MODAL UTILITIES (Defined in module scope) ---
        // These functions will be used by various parts of the app, including setupAuthForms.
        // initializeAppLogic will provide the actual implementations.
        let openModal = (modal) => { console.warn("Modal functions not fully initialized yet."); };
        let closeModal = (modal) => { console.warn("Modal functions not fully initialized yet."); };
        let isModalBlurred = false; // To track blur state globally if needed

        // --- DOM ELEMENTS FOR STARTUP ---
        const loaderOverlay = document.getElementById('loader-overlay');
        const landingPage = document.getElementById('landing-page');
        const appWrapper = document.getElementById('app-wrapper');
        const landingChoices = document.getElementById('landing-choices');
        const landingAuthContainer = document.getElementById('landing-auth-container');
        const googleLoaderModal = document.getElementById('google-signin-loader-modal'); // Cache this element

        // --- Initialize Firebase ---
        try {
            app = window.firebaseSDK.initializeApp(firebaseConfig);
            auth = window.firebaseSDK.getAuth(app);
            db = window.firebaseSDK.getFirestore(app);
            
            // Set up the onAuthStateChanged listener. This is the primary handler for user state changes.
            window.firebaseSDK.onAuthStateChanged(auth, async (user) => {
                // Cleanup previous user's data listeners to prevent memory leaks.
                if (unsubscribeFromFirestore) {
                    unsubscribeFromFirestore(); 
                    unsubscribeFromFirestore = null;
                }
                if (unsubscribeFromFriends) {
                    unsubscribeFromFriends();
                    unsubscribeFromFriends = null;
                }
                
                currentUser = user; // Update the current user reference

                if (user) { // User is logged in
                    // If guest data exists, attempt to merge it with the logged-in user's cloud data.
                    const guestDataString = localStorage.getItem('anonymousUserData');
                    if (guestDataString) {
                        try {
                            // Ensure appController is initialized before trying to merge data
                            if (!appController) {
                                appController = await initializeAppLogic(null); // Initialize with null user first
                            }
                            const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                            const docSnap = await window.firebaseSDK.getDoc(userDocRef);
                            const cloudData = docSnap.exists() && docSnap.data().appData ? docSnap.data().appData : {};
                            const mergedData = mergeGuestDataWithCloud(cloudData);
                            await window.firebaseSDK.setDoc(userDocRef, { appData: mergedData }, { merge: true });
                            localStorage.removeItem('anonymousUserData');
                            sessionStorage.removeItem('isGuest'); // Clear guest session flag
                        } catch (mergeError) {
                            console.error("Failed to merge guest data on login:", mergeError);
                        }
                    }

                    // Initialize or update the app controller with the logged-in user.
                    if (!appController) {
                        appController = await initializeAppLogic(user); // Initialize app logic for the logged-in user
                    } else {
                        await appController.updateUser(user); // Update existing controller if user changed (e.g. refresh)
                    }
                    
                    // Transition from landing page to the main app.
                    landingPage.style.display = 'none';
                    appWrapper.style.display = 'block';
                    loaderOverlay.style.display = 'none';

                } else { // No user is logged in
                    // Check if the user is continuing as a guest.
                    if (sessionStorage.getItem('isGuest')) {
                        if (!appController) {
                            appController = await initializeAppLogic(null); // Initialize app logic for guest
                        }
                        // Transition from landing page to the main app for guest.
                        landingPage.style.display = 'none';
                        appWrapper.style.display = 'block';
                        loaderOverlay.style.display = 'none';
                    } else {
                        // User is fully logged out. Show the landing page.
                        loaderOverlay.style.display = 'none';
                        landingPage.style.display = 'flex';
                        appWrapper.style.display = 'none';
                        // Shut down the app controller to clear all data and stop listeners.
                        if(appController) appController.shutdown();
                        appController = null;
                        currentUser = null; // Ensure currentUser is null when logged out
                    }
                }
            });
        } catch (err) {
            console.error("Firebase initialization failed:", err);
            loaderOverlay.innerHTML = '<p style="color: var(--text);">Error: Could not connect. Please check your Firebase config.</p>';
        }

        // --- LANDING PAGE / AUTH FLOW ---
        function showLandingPage() {
            landingAuthContainer.style.display = 'none';
            landingChoices.style.display = 'block';
            // Clear any auth-specific error messages from the container
            landingAuthContainer.innerHTML = ''; 
        }
        
        document.getElementById('landing-guest-btn').addEventListener('click', async () => {
            sessionStorage.setItem('isGuest', 'true');
            loaderOverlay.style.display = 'flex';
            // Ensure appController is initialized for guests. This call also updates the module-level modal functions.
            if (!appController) {
                appController = await initializeAppLogic(null);
            }
            // Once initialized, transition to the app view.
            landingPage.style.display = 'none';
            appWrapper.style.display = 'block';
            loaderOverlay.style.display = 'none';
        });

        // This function is called when the "Login / Sign Up" button is clicked on the landing page.
        // It needs to set up the authentication UI and handlers.
        async function handleLoginButtonClick() { 
            landingChoices.style.display = 'none';
            landingAuthContainer.style.display = 'block';
            
            const onAuthSuccess = () => {
                // The onAuthStateChanged listener handles the actual redirection/UI update.
                // This callback is primarily for cleanup or specific actions after auth success.
            };
            
            // Call setupAuthForms. It uses the module-scoped openModal/closeModal,
            // which should now be defined by initializeAppLogic (or at least placeholders if it hasn't run yet).
            setupAuthForms(landingAuthContainer, onAuthSuccess);
            
            // Add the "Back" button if it doesn't exist.
            if (!landingAuthContainer.querySelector('#landing-back-btn')) {
                const backBtn = document.createElement('button');
                backBtn.id = 'landing-back-btn';
                backBtn.className = 'btn';
                backBtn.textContent = 'Back';
                backBtn.onclick = showLandingPage;
                landingAuthContainer.appendChild(backBtn);
            }
        }

        document.getElementById('landing-login-btn').addEventListener('click', handleLoginButtonClick);

        // --- MAIN APPLICATION LOGIC ---
        // This function initializes the core application state and logic.
        // It also provides the specific implementations for openModal and closeModal.
        async function initializeAppLogic(initialUser) {
            
            // PLAY SOUND FUNCTION needs to be available for modal/UI interactions
            // Moved playSound definition outside initializeAppLogic to be accessible by setupAuthForms too.
            
            // Helper function to only focus on non-touch devices to prevent mobile keyboard auto-opening
            const focusOnDesktop = (el) => {
                if (!window.matchMedia('(pointer: coarse)').matches && el) {
                    el.focus();
                }
            };

            // --- MODAL UTILITIES (Provide actual implementations) ---
            // These update the module-scoped openModal and closeModal functions.
            const openModalImpl = (modal) => { 
                if(modal) {
                    // Ensure any active mobile task action menus are closed
                    if (activeMobileActionsItem) { 
                        activeMobileActionsItem.classList.remove('actions-visible');
                        activeMobileActionsItem = null;
                    }
                    // Blur the background app content
                    appWrapper.classList.add('blur-background');
                    modal.classList.add('visible');
                    playSound('open'); // Use the module-scoped playSound
                }
            };
            const closeModalImpl = (modal) => { 
                if(modal) {
                    appWrapper.classList.remove('blur-background');
                    modal.classList.remove('visible');
                    playSound('close'); // Use the module-scoped playSound
                }
            };
            
            // Update the module-scoped functions with these implementations.
            openModal = openModalImpl;
            closeModal = closeModalImpl;

            // --- APPLICATION STATE VARIABLES ---
            let user = initialUser; // Current logged-in user or null for guest/logged out
            // Default settings, will be overwritten by loaded data
            let settings = { theme: 'system', accentColor: 'var(--accent-red)', volume: 0.3 }; 
            const audioCtx = window.AudioContext ? new AudioContext() : null; // Audio context for sound effects
            
            // Sound playback function (moved outside initializeAppLogic)
            // It will be used by modal functions and other parts of the app.
            
            let lastSection = 'daily'; // Tracks the last viewed section in mobile nav
            let dailyTasks = [], standaloneMainQuests = [], generalTaskGroups = []; // Task data
            let playerData = { level: 1, xp: 0 }; // Player stats
            let currentListToAdd = null, currentEditingTaskId = null; // State for modals
            const activeTimers = {}; // Stores interval IDs for active timers
            let actionsTimeoutId = null; // Timeout for mobile task action visibility
            let activeMobileActionsItem = null; // Tracks which task item has actions visible on mobile
            
            // --- DOM ELEMENT REFERENCES ---
            // These are obtained within initializeAppLogic as they are specific to the main app view.
            const dailyTaskListContainer = document.getElementById('daily-task-list');
            const standaloneTaskListContainer = document.getElementById('standalone-task-list');
            const generalTaskListContainer = document.getElementById('general-task-list-container');
            const playerLevelEl = document.getElementById('player-level');
            const xpBarEl = document.getElementById('xp-bar');
            const xpTextEl = document.getElementById('xp-text');
            const levelDisplayEl = document.querySelector('.level-display');
            const addTaskTriggerBtnDaily = document.querySelector('.add-task-trigger-btn[data-list="daily"]');
            const addStandaloneTaskBtn = document.getElementById('add-standalone-task-btn');
            const addGroupBtn = document.getElementById('add-group-btn');
            
            const addTaskModal = document.getElementById('add-task-modal');
            const addTaskModalTitle = document.getElementById('add-task-modal-title');
            const addTaskForm = document.getElementById('add-task-form');
            const newTaskInput = document.getElementById('new-task-input');
            
            const editTaskModal = document.getElementById('edit-task-modal');
            const editTaskForm = document.getElementById('edit-task-form');
            const editTaskInput = document.getElementById('edit-task-input');
            const editTaskIdInput = document.getElementById('edit-task-id');
            const editWeeklyGoalContainer = document.getElementById('edit-weekly-goal-container');

            const weeklyGoalContainer = document.getElementById('weekly-goal-container');
            const weeklyGoalSlider = document.getElementById('new-task-weekly-goal-slider');
            const weeklyGoalDisplay = document.getElementById('new-task-weekly-goal-display');
            const editWeeklyGoalSlider = document.getElementById('edit-task-weekly-goal-slider');
            const editWeeklyGoalDisplay = document.getElementById('edit-task-weekly-goal-display');

            const addGroupModal = document.getElementById('add-group-modal');
            const addGroupForm = document.getElementById('add-group-form');
            const newGroupInput = document.getElementById('new-group-input');
            const timerModal = document.getElementById('timer-modal');
            const timerForm = document.getElementById('timer-form');
            const timerDurationSlider = document.getElementById('timer-duration-slider');
            const timerDurationDisplay = document.getElementById('timer-duration-display');
            const timerUnitSelector = document.querySelector('.timer-unit-selector');
            const timerMenuModal = document.getElementById('timer-menu-modal');
            const timerMenuCancelBtn = document.getElementById('timer-menu-cancel-btn');
            const settingsBtn = document.getElementById('settings-btn');
            const settingsModal = document.getElementById('settings-modal');
            const themeOptionsButtons = document.getElementById('theme-options-buttons');
            const colorOptions = document.getElementById('color-options');
            const volumeSlider = document.getElementById('volume-slider');
            const resetProgressBtn = document.getElementById('reset-progress-btn');
            const exportDataBtn = document.getElementById('export-data-btn');
            const importDataBtn = document.getElementById('import-data-btn');
            const importFileInput = document.getElementById('import-file-input');
            const dataManagementHeading = document.getElementById('data-management-heading');
            const settingsLoginBtn = document.getElementById('settings-login-btn');
            const manageAccountBtn = document.getElementById('manage-account-btn');
            const logoutBtn = document.getElementById('logout-btn');
            const userDisplay = document.getElementById('user-display');
            const accountModal = document.getElementById('account-modal');
            const manageAccountModal = document.getElementById('manage-account-modal');
            const confirmModal = document.getElementById('confirm-modal');
            const confirmActionBtn = document.getElementById('confirm-action-btn');
            const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
            const confirmTitle = document.getElementById('confirm-title');
            const confirmText = document.getElementById('confirm-text');
            const noDailyTasksMessage = document.getElementById('no-daily-tasks-message');
            const noGeneralTasksMessage = document.getElementById('no-general-tasks-message');
            const quoteEl = document.getElementById('quote-of-the-day');
            let confirmCallback = null; // Callback for the confirmation modal
            
            // Friends feature DOM elements
            const friendsBtnDesktop = document.getElementById('friends-btn-desktop');
            const friendsModal = document.getElementById('friends-modal');
            const mobileNav = document.getElementById('mobile-nav');
            const addFriendForm = document.getElementById('add-friend-form');
            const searchUsernameInput = document.getElementById('search-username-input');
            const friendStatusMessage = friendsModal.querySelector('.friend-status-message');
            const friendRequestCountBadge = document.getElementById('friend-request-count');
            const friendsListContainer = friendsModal.querySelector('.friends-list-container');
            const friendRequestsContainer = friendsModal.querySelector('.friend-requests-container');
            const deleteAccountBtn = document.getElementById('delete-account-btn'); // For manage account modal


            // =========================================================================
            // SOUND UTILITIES (Moved outside initializeAppLogic for broader scope)
            // =========================================================================
            function playSound(type) {
                if (!audioCtx || settings.volume === 0) return; // Don't play if audio is disabled or muted
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.connect(g); g.connect(audioCtx.destination);
                let v = settings.volume, d = 0.2; // Default duration and volume multiplier
                switch (type) {
                    case 'complete': o.type = 'sine'; o.frequency.setValueAtTime(440, audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.2); break;
                    case 'levelUp': o.type = 'sawtooth'; o.frequency.setValueAtTime(200, audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.4); d = 0.4; v *= 1.2; break; // Louder and longer for level up
                    case 'timerUp': o.type = 'square'; o.frequency.setValueAtTime(880, audioCtx.currentTime); o.frequency.linearRampToValueAtTime(440, audioCtx.currentTime + 0.5); d = 0.5; break; // Longer timer alert
                    case 'add': case 'addGroup': o.type = 'triangle'; o.frequency.setValueAtTime(300, audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1); d = 0.15; break;
                    case 'delete': o.type = 'square'; o.frequency.setValueAtTime(200, audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1); break;
                    case 'hover': o.type = 'sine'; o.frequency.setValueAtTime(800, audioCtx.currentTime); v *= 0.2; d = 0.05; break; // Quiet hover sound
                    case 'toggle': o.type = 'sawtooth'; o.frequency.setValueAtTime(200, audioCtx.currentTime); o.frequency.linearRampToValueAtTime(400, audioCtx.currentTime + 0.1); d = 0.1; break; // For toggling states
                    case 'open': o.type = 'triangle'; o.frequency.setValueAtTime(250, audioCtx.currentTime); o.frequency.linearRampToValueAtTime(500, audioCtx.currentTime + 0.1); break; // Modal open sound
                    case 'close': o.type = 'triangle'; o.frequency.setValueAtTime(500, audioCtx.currentTime); o.frequency.linearRampToValueAtTime(250, audioCtx.currentTime + 0.1); break; // Modal close sound
                }
                g.gain.setValueAtTime(0, audioCtx.currentTime); g.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.01); // Fade in gain
                o.start(audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + d); // Fade out gain
                o.stop(audioCtx.currentTime + d); // Stop oscillator after duration
            }

            // Prompt for username if the user doesn't have one yet (only for signed-in users)
            async function promptForUsernameIfNeeded() {
                if (!user) return; // Skip for guests

                const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                const docSnap = await window.firebaseSDK.getDoc(userDocRef);
                const existingData = docSnap.exists() ? docSnap.data().appData : null;
                
                // Check if the user signed up with email/password or via a provider that doesn't require a username prompt
                const isEmailUser = user.providerData.some(p => p.providerId === 'password');
                // If it's a new user OR they don't have a username AND they signed up via email/password (where username is part of signup)
                // OR if it's a provider that requires a username setup step.
                if (!docSnap.exists() || !docSnap.data().username) {
                    const usernameModal = document.getElementById('username-modal');
                    const usernameForm = document.getElementById('username-form');
                    const newUsernameInput = document.getElementById('new-username-input');
                    const usernameErrorEl = usernameModal.querySelector('.username-error');
                    
                    usernameModal.setAttribute('data-persistent', 'true'); // Prevent closing by clicking outside

                    openModal(usernameModal); // Use the module-scoped openModal
                    focusOnDesktop(newUsernameInput);

                    return new Promise((resolve) => {
                        usernameForm.onsubmit = async (e) => {
                            e.preventDefault();
                            usernameErrorEl.textContent = '';
                            const username = newUsernameInput.value.trim().toLowerCase();
                            if (!username || username.length < 3) {
                                usernameErrorEl.textContent = 'Username must be at least 3 characters.';
                                return;
                            }

                            const submitButton = usernameForm.querySelector('button[type="submit"]');
                            submitButton.disabled = true;
                            submitButton.textContent = 'Saving...';
                            
                            try {
                                // Check if username is available
                                const usernamesRef = window.firebaseSDK.doc(db, "usernames", username);
                                const usernameSnap = await window.firebaseSDK.getDoc(usernamesRef);

                                if (usernameSnap.exists()) {
                                    throw new Error('This username is already taken.');
                                }

                                // Use batch write for atomicity: create username entry and user profile
                                const batch = window.firebaseSDK.writeBatch(db);
                                batch.set(usernamesRef, { userId: user.uid });
                                batch.set(userDocRef, { 
                                    username: username, 
                                    email: user.email, // Store email as well for auth
                                    appData: existingData || {}, // Preserve existing app data if any
                                    friends: [], // Initialize friends list
                                    friendRequests: [] // Initialize friend requests list
                                }, { merge: true }); // Use merge to avoid overwriting other fields if they exist
                                await batch.commit();
                                
                                usernameModal.removeAttribute('data-persistent'); // Allow closing modal
                                closeModal(usernameModal); // Use module-scoped closeModal
                                resolve(); // Resolve the promise, indicating username setup is complete

                            } catch (error) {
                                usernameErrorEl.textContent = error.message || getCoolErrorMessage(error);
                            } finally {
                                submitButton.disabled = false;
                                submitButton.textContent = 'Save Username';
                            }
                        };
                    });
                }
            }
            
            // =========================================================================
            // DATA PERSISTENCE & OPTIMIZATION
            // =========================================================================

            /**
             * Debounce function to delay execution. This is a core optimization strategy
             * to reduce the number of writes to Firestore by grouping multiple rapid
             * changes into a single save operation.
             * @param {Function} func The function to debounce.
             * @param {number} delay The delay in milliseconds.
             * @returns {Function} The new debounced function.
             */
            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            // This function handles saving data to localStorage (for guests) or Firestore (for logged-in users).
            async function saveData(data) {
                // Also save theme to a simple key for faster pre-load on app start
                if (data.settings && data.settings.theme) {
                    localStorage.setItem('userTheme', data.settings.theme);
                }

                if (!user) { // For guests, save to local storage
                    localStorage.setItem('anonymousUserData', JSON.stringify(data));
                    return;
                }
                
                // For logged-in users, save to Firestore
                try {
                    const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                    await window.firebaseSDK.setDoc(userDocRef, { appData: data }, { merge: true });
                } catch (error) { 
                    console.error("Error saving data to Firestore: ", getCoolErrorMessage(error)); 
                }
            }
            
            // Create a debounced version of the saveData function.
            // It will wait 1500ms (1.5 seconds) after the last action before saving to Firestore.
            const debouncedSaveData = debounce(saveData, 1500);

            // This function is called after any state change in the application that needs saving.
            const saveState = () => {
                const dataToSave = { 
                    dailyTasks, 
                    standaloneMainQuests, 
                    generalTaskGroups, 
                    playerData, 
                    settings 
                };
                
                // OPTIMIZATION:
                // - For guests, save instantly to localStorage (it's free and fast).
                // - For logged-in users, use the debounced function to avoid excessive Firestore writes.
                if (!user) {
                    saveData(dataToSave);
                } else {
                    debouncedSaveData(dataToSave);
                }
            };
            
            // =========================================================================
            // END OF DATA PERSISTENCE & OPTIMIZATION
            // =========================================================================

            // Function to load and display data from a given source (local or cloud).
            function loadAndDisplayData(data) {
                dailyTasks = data.dailyTasks || [];
                standaloneMainQuests = data.standaloneMainQuests || [];
                generalTaskGroups = data.generalTaskGroups || [];
                playerData = data.playerData || { level: 1, xp: 0 };
                // Overwrite default settings with loaded data, preserving defaults if not found.
                settings = { ...settings, ...(data.settings || {}) }; 
                
                // Ensure default state for new properties (e.g., group expansion)
                generalTaskGroups.forEach(group => {
                    if (typeof group.isExpanded === 'undefined') group.isExpanded = false;
                });

                applySettings(); // Apply theme and accent color settings
                renderAllLists(); // Render all tasks and groups
                updateProgressUI(); // Update XP bar and level display
            }

            // Handles the initial loading of data when the app starts or the user logs in/out.
            async function initialLoad() {
                return new Promise((resolve) => {
                    if (!user) { // Guest user or logged out state
                        const localData = JSON.parse(localStorage.getItem('anonymousUserData')) || {};
                        loadAndDisplayData(localData);
                        resolve(); // Data loaded from local storage
                        return;
                    }
                    
                    // Logged-in user: Set up real-time listener for Firestore data.
                    listenForFriendRequests(); // Start listening for friend requests

                    const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                    let isFirstLoad = true; // Flag to ensure resolve is called only once
                    
                    unsubscribeFromFirestore = window.firebaseSDK.onSnapshot(userDocRef, (docSnap) => {
                        if (docSnap.exists() && docSnap.data().appData) {
                            loadAndDisplayData(docSnap.data().appData); // Load data from Firestore
                        } else {
                            loadAndDisplayData({}); // Load empty state if user document or appData is missing (new user)
                        }
                        // Resolve the promise only after the first successful data load.
                        if (isFirstLoad) {
                            isFirstLoad = false;
                            resolve();
                        }
                    }, (error) => {
                        console.error("Error listening to Firestore:", getCoolErrorMessage(error));
                        // If there's an error during the first load, still resolve to allow app to start.
                        if (isFirstLoad) {
                             isFirstLoad = false;
                             resolve();
                        }
                    });
                });
            }

            // Updates the UI elements related to the user's logged-in status (e.g., settings menu).
            async function updateUserUI() {
                if (user) { // User is logged in
                    settingsLoginBtn.style.display = 'none';
                    logoutBtn.style.display = 'inline-flex';
                    manageAccountBtn.style.display = 'inline-flex'; // Show manage account button

                    const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                    const docSnap = await window.firebaseSDK.getDoc(userDocRef);
                    // Display username if available, otherwise fall back to email.
                    const username = docSnap.exists() && docSnap.data().username ? docSnap.data().username : user.email;

                    userDisplay.textContent = `Logged in as: ${username}`;
                    userDisplay.style.display = 'flex';
                    dataManagementHeading.textContent = "Cloud Data"; // Change heading for logged-in users
                    exportDataBtn.style.display = 'none'; // Hide guest data export
                    importDataBtn.style.display = 'none'; // Hide guest data import
                    resetProgressBtn.textContent = 'Reset Cloud Data'; // Adjust button text
                    
                    // Show friends-related UI elements for logged-in users
                    friendsBtnDesktop.style.display = 'flex';
                    mobileNav.querySelector('[data-section="friends"]').style.display = 'flex';

                } else { // User is logged out or viewing as guest
                    settingsLoginBtn.style.display = 'inline-flex';
                    logoutBtn.style.display = 'none';
                    manageAccountBtn.style.display = 'none';
                    userDisplay.textContent = 'Playing as Guest';
                    userDisplay.style.display = 'flex';
                    dataManagementHeading.textContent = "Guest Data (Local)"; // Change heading for guests
                    exportDataBtn.style.display = 'inline-flex'; // Show guest data export
                    importDataBtn.style.display = 'inline-flex'; // Show guest data import
                    resetProgressBtn.textContent = 'Reset Progress'; // Reset button text for guests
                    
                    // Hide friends-related UI elements for guests
                    friendsBtnDesktop.style.display = 'none';
                    mobileNav.querySelector('[data-section="friends"]').style.display = 'none';
                }
            }

            // Constants for XP calculation
            const XP_PER_TASK = 35;
            const XP_PER_TIMER_MINUTE = 2;
            // Function to calculate XP needed for the next level
            const getXpForNextLevel = (level) => 50 + (level * 50);

            // Array of motivational quotes
            const quotes = [
                "The secret of getting ahead is getting started.", 
                "A year from now you may wish you had started today.", 
                "The future depends on what you do today.",
                "It always seems impossible until it's done.",
                "Don't watch the clock; do what it does. Keep going."
            ];
            // Function to display a random quote in the header
            function showRandomQuote() { quoteEl.textContent = `"${quotes[Math.floor(Math.random() * quotes.length)]}"`; }
            
            // Helper to get the start of the current week (Monday)
            const getStartOfWeek = (date) => {
                const d = new Date(date);
                const day = d.getDay(); // Sunday - 0, Monday - 1, ... Saturday - 6
                // Adjust date to the most recent Monday (or Sunday if day is 0, then subtract 6 days)
                const diff = d.getDate() - day + (day === 0 ? -6 : 1); 
                return new Date(d.setDate(diff)).setHours(0, 0, 0, 0); // Set time to midnight
            };

            // Checks if it's a new day and resets daily quests, updating streaks.
            const checkDailyReset = () => {
                const today = new Date().toDateString();
                const lastVisit = localStorage.getItem('lastVisitDate');
                
                if (today !== lastVisit) { // It's a new day
                    const yesterday = new Date(Date.now() - 86400000).toDateString(); // Get yesterday's date string
                    dailyTasks.forEach(task => {
                        // If task was completed yesterday, increment streak. Otherwise, reset streak.
                        if (task.completedToday && task.lastCompleted === yesterday) {
                            task.streak = (task.streak || 0) + 1;
                        } else if (!task.completedToday) { // Only reset streak if not completed today (meaning it wasn't completed yesterday either)
                            task.streak = 0;
                        }
                        // Reset completion status for today
                        task.completedToday = false;
                        task.lastCompleted = null; 
                        // Reset weekly goal completions if the week has changed
                        if (task.weeklyGoal > 0) {
                            const now = new Date();
                            if (task.weekStartDate < getStartOfWeek(now)) {
                                task.weekStartDate = getStartOfWeek(now);
                                task.weeklyCompletions = 0;
                            }
                        }
                    });
                    localStorage.setItem('lastVisitDate', today); // Update last visit date
                    saveState(); // Save the reset state
                }
            };

            // Adds XP to the player, handling level ups.
            function addXp(amount) {
                playerData.xp += Math.round(amount);
                if (playerData.xp < 0) playerData.xp = 0; // Ensure XP doesn't go below zero
                
                const requiredXp = getXpForNextLevel(playerData.level);
                if (playerData.xp >= requiredXp) {
                    levelUp(requiredXp); // Trigger level up if enough XP
                }
                updateProgressUI(); // Update XP bar visually
            }

            // Handles the level up process.
            function levelUp(requiredXp) {
                playerData.level++;
                playerData.xp -= requiredXp; // Subtract XP used for level up
                playSound('levelUp'); // Play level up sound
                levelDisplayEl.classList.add('level-up'); // Add class for animation
                // Remove animation class after it finishes
                levelDisplayEl.addEventListener('animationend', () => levelDisplayEl.classList.remove('level-up'), { once: true });
                
                // Check if the player leveled up multiple times with the gained XP
                const newRequiredXp = getXpForNextLevel(playerData.level);
                if (playerData.xp >= newRequiredXp) {
                    levelUp(newRequiredXp); // Recursive call for multiple level ups
                }
            }

            // Updates the XP bar and level text in the UI.
            function updateProgressUI() {
                const requiredXp = getXpForNextLevel(playerData.level);
                // Calculate progress percentage, capping at 100%
                const progressPercent = Math.min((playerData.xp / requiredXp) * 100, 100);
                playerLevelEl.textContent = playerData.level;
                xpTextEl.textContent = `${Math.floor(playerData.xp)} / ${requiredXp} XP`;
                xpBarEl.style.width = `${progressPercent}%`;
            }

            // Checks tasks for overdue status and applies styling.
            function checkOverdueTasks() {
                const now = Date.now();
                const allTasks = [...dailyTasks, ...standaloneMainQuests, ...generalTaskGroups.flatMap(g => g.tasks || [])];
                
                allTasks.forEach(task => {
                    const taskEl = document.querySelector(`.task-item[data-id="${task.id}"]`);
                    if (!taskEl || task.completedToday) return; // Skip if element not found or task is completed today
                    
                    // Mark as overdue if task creation time was more than 24 hours ago
                    taskEl.classList.toggle('overdue', (now - task.createdAt) > 86400000);
                });
            }

            // Checks if all daily tasks are completed and if all tasks in the app are done.
            function checkAllTasksCompleted() {
                const allDailiesDone = dailyTasks.length > 0 && dailyTasks.every(t => t.completedToday);
                const noStandaloneQuests = standaloneMainQuests.length === 0;
                const noGroupedQuests = generalTaskGroups.every(g => !g.tasks || g.tasks.length === 0);
                return { allDailiesDone, allTasksDone: allDailiesDone && noStandaloneQuests && noGroupedQuests };
            }
            
            // --- RENDERING FUNCTIONS ---
            // Renders the list of daily tasks.
            const renderDailyTasks = () => { 
                dailyTaskListContainer.innerHTML = ''; // Clear existing list
                noDailyTasksMessage.style.display = dailyTasks.length === 0 ? 'block' : 'none'; // Show message if list is empty
                dailyTasks.forEach(task => dailyTaskListContainer.appendChild(createTaskElement(task, 'daily'))); // Append each task element
            };
            // Renders the list of standalone main quests.
            const renderStandaloneTasks = () => { 
                standaloneTaskListContainer.innerHTML = ''; 
                standaloneMainQuests.forEach(task => standaloneTaskListContainer.appendChild(createTaskElement(task, 'standalone'))); 
            };
            // Renders all general task groups.
            const renderGeneralTasks = () => { 
                generalTaskListContainer.innerHTML = ''; 
                generalTaskGroups.forEach(group => generalTaskListContainer.appendChild(createGroupElement(group))); 
                // Show message if there are no standalone quests and no general groups
                noGeneralTasksMessage.style.display = (standaloneMainQuests.length === 0 && generalTaskGroups.length === 0) ? 'block' : 'none'; 
            };
            
            // Creates the HTML element for a task group.
            const createGroupElement = (group) => {
                const el = document.createElement('div'); 
                el.className = 'main-quest-group'; 
                if (group.isExpanded) el.classList.add('expanded'); // Add expanded class if group is expanded
                el.dataset.groupId = group.id; // Set data attribute for group ID
                
                el.innerHTML = `
                    <header class="main-quest-group-header">
                        <div class="group-title-container">
                            <svg class="expand-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/></svg>
                            <h3>${group.name}</h3>
                        </div>
                        <div class="group-actions">
                            <button class="btn icon-btn edit-group-btn" aria-label="Edit group name"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z"/></svg></button>
                            <button class="btn icon-btn delete-group-btn" aria-label="Delete group"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>
                            <button class="btn add-task-to-group-btn" aria-label="Add task">+</button>
                        </div>
                    </header>
                    <ul class="task-list-group" data-group-id="${group.id}"></ul>
                `;
                const ul = el.querySelector('ul'); // Get the unordered list for tasks
                if (group.tasks) { // If the group has tasks, render them
                    group.tasks.forEach(task => ul.appendChild(createTaskElement(task, 'group')));
                }
                return el; // Return the created group element
            };
            
            // Creates the HTML element for a single task item.
            const createTaskElement = (task, type) => {
                const li = document.createElement('li'); 
                li.className = 'task-item'; 
                li.dataset.id = task.id; // Set data attribute for task ID
                if (type === 'standalone') li.classList.add('standalone-quest'); // Style standalone quests differently

                // Generate streak counter HTML if it's a daily task with a streak > 0
                let streakHTML = ''; 
                if (type === 'daily' && task.streak > 0) {
                    streakHTML = `
                        <div class="streak-counter" title="Current Streak: ${task.streak}">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M17.653 9.473c.071.321.11.65.11.986 0 2.21-1.791 4-4 4s-4-1.79-4-4c0-.336.039-.665.11-.986C7.333 11.23 6 14.331 6 18h12c0-3.669-1.333-6.77-3.347-8.527zM12 2C9.239 2 7 4.239 7 7c0 .961.261 1.861.713 2.638C9.223 8.36 10.55 7.5 12 7.5s2.777.86 4.287 2.138C17 8.861 17 7.961 17 7c0-2.761-2.239-5-5-5z"/></svg>
                            <span>${task.streak}</span>
                        </div>
                    `;
                }

                // Generate weekly goal tag HTML if applicable
                let goalHTML = ''; 
                if (type === 'daily' && task.weeklyGoal > 0) {
                    goalHTML = `
                        <div class="weekly-goal-tag" title="Weekly Goal Progress">
                            <span>${task.weeklyCompletions}/${task.weeklyGoal}</span>
                        </div>
                    `;
                    // Add 'weekly-goal-met' class if the goal is achieved
                    if (task.weeklyCompletions >= task.weeklyGoal) {
                        li.classList.add('weekly-goal-met'); 
                    }
                }

                // Set the inner HTML for the task item
                li.innerHTML = `
                    <button class="complete-btn"></button> 
                    <div class="task-content">
                        ${streakHTML} 
                        <span class="task-text">${task.text}</span>
                        ${goalHTML}
                    </div>
                    <div class="task-buttons-wrapper">
                        <button class="btn icon-btn timer-clock-btn" aria-label="Set Timer">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                            <svg class="progress-ring" viewBox="0 0 24 24">
                                <circle class="progress-ring-circle" r="10" cx="12" cy="12"/>
                            </svg>
                        </button>
                        <div class="task-actions">
                            <button class="btn icon-btn edit-btn" aria-label="Edit Task"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z"/></svg></button>
                            <button class="btn icon-btn delete-btn" aria-label="Delete Task"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>
                        </div>
                    </div>
                `;

                // Apply specific styles based on task state
                if (task.completedToday) { 
                    li.classList.add('daily-completed'); 
                    li.querySelector('.complete-btn').classList.add('checked'); 
                }
                if (task.timerFinished) { 
                    li.classList.add('timer-finished'); 
                }
                // Handle active timers visually
                if (task.timerStartTime && task.timerDuration) {
                    const elapsed = (Date.now() - task.timerStartTime) / 1000;
                    const remaining = Math.max(0, task.timerDuration - elapsed);
                    if (remaining > 0) {
                        li.classList.add('timer-active');
                        const ring = li.querySelector('.progress-ring-circle');
                        if (ring) {
                            const r = ring.r.baseVal.value; // Get the radius of the circle element
                            if (r > 0) {
                                const c = r * 2 * Math.PI; // Circumference
                                const p = remaining / task.timerDuration; // Progress percentage
                                ring.style.strokeDashoffset = c - (p * c); // Set offset for progress indicator
                            }
                        }
                    }
                }
                return li; // Return the created task list item element
            };
            
            // --- TASK MANAGEMENT FUNCTIONS ---

            // Adds a new task to the specified list ('daily', 'standalone', or a group ID).
            const addTask = (text, list, goal) => {
                const common = { id: Date.now().toString(), text, createdAt: Date.now() }; // Common properties for all tasks
                if (list === 'daily') {
                    dailyTasks.push({ 
                        ...common, 
                        completedToday: false, 
                        lastCompleted: null, 
                        streak: 0, 
                        weeklyGoal: goal || 0, 
                        weeklyCompletions: 0, 
                        weekStartDate: getStartOfWeek(new Date()) // Record the start of the week
                    });
                } else if (list === 'standalone') {
                    standaloneMainQuests.push({ ...common });
                } else { // Adding to a specific group
                    const g = generalTaskGroups.find(g => g.id === list); 
                    if (g) { 
                        if (!g.tasks) g.tasks = []; // Initialize tasks array if it doesn't exist
                        g.tasks.push({ ...common }); 
                    }
                }
                renderAllLists(); // Re-render all lists to show the new task
                saveState(); // Save the updated state
                playSound('add'); // Play sound effect
            };

            // Adds a new task group.
            const addGroup = (name) => { 
                generalTaskGroups.push({ id: 'group_' + Date.now(), name, tasks: [], isExpanded: false }); // New group properties
                renderAllLists();
                saveState(); 
                playSound('addGroup'); 
            };

            // Deletes a task group and all its tasks.
            const deleteGroup = (id) => { 
                const groupNameToDelete = generalTaskGroups.find(g => g.id === id)?.name || 'this group'; // Get group name for confirmation
                showConfirm(`Delete "${groupNameToDelete}"?`, 'All tasks within this group will also be deleted.', () => { 
                    generalTaskGroups = generalTaskGroups.filter(g => g.id !== id); // Filter out the group to delete
                    renderAllLists(); 
                    saveState(); 
                    playSound('delete'); 
                });
            };

            // Finds a task and its context (list, group) by its ID.
            const findTaskAndContext = (id) => {
                let task = dailyTasks.find(t => t && t.id === id); 
                if (task) return { task, list: dailyTasks, type: 'daily' };
                
                task = standaloneMainQuests.find(t => t && t.id === id); 
                if(task) return { task, list: standaloneMainQuests, type: 'standalone'};
                
                for (const g of generalTaskGroups) { 
                    if (g && g.tasks) { 
                        const i = g.tasks.findIndex(t => t && t.id === id); 
                        if (i !== -1) return { task: g.tasks[i], list: g.tasks, group: g, type: 'group' }; 
                    } 
                } 
                return {}; // Return empty object if task not found
            };

            // Deletes a task.
            const deleteTask = (id) => { 
                stopTimer(id, false); // Stop any running timer for this task
                const { list } = findTaskAndContext(id); // Find the list the task belongs to
                if (list) { 
                    const i = list.findIndex(t => t.id === id); 
                    if(i > -1) list.splice(i, 1); // Remove task from its list
                }
                // If the task was in a group and the group is now empty, consider removing the group.
                const { group } = findTaskAndContext(id);
                if (group && group.tasks && group.tasks.length === 0) {
                    const groupIndex = generalTaskGroups.findIndex(g => g.id === group.id);
                    if (groupIndex > -1) {
                        generalTaskGroups.splice(groupIndex, 1); // Remove empty group
                    }
                }
                renderAllLists(); 
                saveState(); 
                playSound('delete'); 
            };

            // Marks a task as completed.
            const completeTask = (id) => {
                stopTimer(id, false); // Stop timer if running
                const { task, type } = findTaskAndContext(id); 
                if (!task) return; // Exit if task not found

                if (task.timerFinished) delete task.timerFinished; // Remove timer finished state

                addXp(XP_PER_TASK); // Award XP for task completion
                playSound('complete'); // Play completion sound

                if (type === 'daily') {
                    if (task.completedToday) return; // Already completed today, do nothing
                    task.completedToday = true; // Mark as completed today
                    task.lastCompleted = new Date().toDateString(); // Record completion date
                    // Update weekly goal progress
                    if (task.weeklyGoal > 0) {
                        const now = new Date();
                        if (task.weekStartDate < getStartOfWeek(now)) { // If week has reset
                            task.weekStartDate = getStartOfWeek(now); // Update week start date
                            task.weeklyCompletions = 1; // Reset completions for the new week
                        } else {
                            task.weeklyCompletions = (task.weeklyCompletions || 0) + 1; // Increment weekly completions
                        }
                    }
                } else { // For non-daily tasks (standalone or group tasks)
                    createConfetti(document.querySelector(`.task-item[data-id="${id}"]`)); // Trigger confetti effect
                    const { list, group } = findTaskAndContext(id); // Find task's list and group
                    if (list) { 
                        const i = list.findIndex(t => t.id === id); 
                        if(i > -1) list.splice(i, 1); // Remove task from its list
                    }
                    // If completing a task makes its group empty, remove the group
                    if (group && (!group.tasks || group.tasks.length === 0)) {
                        const groupIndex = generalTaskGroups.findIndex(g => g.id === group.id);
                        if (groupIndex > -1) {
                            generalTaskGroups.splice(groupIndex, 1);
                        }
                    }
                }
                saveState(); // Save changes
                renderAllLists(); // Re-render lists to reflect changes

                // Check for overall completion celebration
                const { allDailiesDone, allTasksDone } = checkAllTasksCompleted(); 
                if (allTasksDone) { 
                    createFullScreenConfetti(true); // Full party mode if everything is done
                } else if (allDailiesDone) { 
                    createFullScreenConfetti(false); // Confetti if only dailies are done
                }
            };

            // Unmarks a daily task as completed.
            const uncompleteDailyTask = (id) => { 
                const task = dailyTasks.find(t => t.id === id); 
                if (task && task.completedToday) { 
                    task.completedToday = false; // Unmark completion
                    // Decrement weekly completion count if it was marked for today
                    if (task.weeklyGoal > 0 && task.lastCompleted === new Date().toDateString()) {
                        task.weeklyCompletions = Math.max(0, (task.weeklyCompletions || 0) - 1); 
                    }
                    addXp(-XP_PER_TASK); // Remove XP gained from completing this task
                    playSound('delete'); // Play sound effect
                    saveState(); 
                    renderAllLists(); 
                } 
            };

            // Edits an existing task's text and weekly goal.
            const editTask = (id, text, goal) => {
                const { task, type } = findTaskAndContext(id); // Find the task
                if (task) {
                    task.text = text; // Update task text
                    if (type === 'daily') {
                        task.weeklyGoal = goal; // Update weekly goal only for daily tasks
                    }
                    saveState(); 
                    renderAllLists(); 
                }
            };

            // Function called when a timer successfully finishes.
            function finishTimer(id) {
                playSound('timerUp'); // Play timer finished sound
                stopTimer(id, false); // Stop the timer interval (don't re-render yet)
                const { task } = findTaskAndContext(id);
                if (task) {
                    task.timerFinished = true; // Mark timer as finished
                    delete task.timerStartTime; // Clean up timer start time
                    delete task.timerDuration; // Clean up timer duration
                    saveState(); // Save the state change
                    renderAllLists(); // Re-render to show the finished timer state
                }
            }

            // Starts a timer for a specific task.
            function startTimer(id, durationInMinutes) {
                stopTimer(id, false); // Stop any existing timer for this task
                const { task } = findTaskAndContext(id); // Find the task
                if (!task) return; // Exit if task not found

                task.timerStartTime = Date.now(); // Record when timer started
                task.timerDuration = durationInMinutes * 60; // Store duration in seconds
                delete task.timerFinished; // Remove timer finished state if it was previously set
                
                saveState(); // Save the state with timer active
                renderAllLists(); // Re-render to show the active timer
            }

            // Stops a running timer for a task.
            function stopTimer(id, shouldRender = true) { // `shouldRender` flag to control immediate UI update
                if (activeTimers[id]) {
                    clearInterval(activeTimers[id]); // Clear the interval
                    delete activeTimers[id]; // Remove from active timers map
                }
                const { task } = findTaskAndContext(id);
                if (task) {
                    // Clean up timer properties from the task object
                    delete task.timerStartTime;
                    delete task.timerDuration;
                    if (shouldRender) { // Re-render if requested
                        saveState();
                        renderAllLists();
                    }
                }
            }

            // Resumes all active timers when the app loads or reloads.
            function resumeTimers() {
                // Clear any existing timer intervals before resuming
                Object.keys(activeTimers).forEach(id => clearInterval(activeTimers[id]));
                activeTimers = {}; // Reset the active timers map
                
                let needsSaveAndRender = false; // Flag to indicate if state needs saving/rendering after resuming
                // Iterate through all tasks to find active timers
                const allTasks = [...dailyTasks, ...standaloneMainQuests, ...generalTaskGroups.flatMap(g => g.tasks || [])];
                
                allTasks.forEach(t => {
                    if (t && t.timerStartTime && t.timerDuration) { // Check if timer properties exist
                        const elapsed = (Date.now() - t.timerStartTime) / 1000;
                        const remainingSeconds = t.timerDuration - elapsed;
                        
                        if (remainingSeconds > 0) { // If timer is still running
                             // Set up a new interval for this timer
                             activeTimers[t.id] = setInterval(() => {
                                const currentElapsed = (Date.now() - (t.timerStartTime || 0)) / 1000;
                                const currentRemaining = (t.timerDuration || 0) - currentElapsed;
                                
                                const taskEl = document.querySelector(`.task-item[data-id="${t.id}"]`);
                                // If the task element is no longer on the page or the timer was stopped externally, clear the interval
                                if (!taskEl || !activeTimers[t.id]) {
                                    clearInterval(activeTimers[t.id]);
                                    delete activeTimers[t.id];
                                    return;
                                }

                                if (currentRemaining > 0) { // If time is still remaining
                                    const ring = taskEl.querySelector('.progress-ring-circle');
                                    if (ring) { // Update the visual progress ring
                                        const r = ring.r.baseVal.value;
                                        if (r > 0) {
                                            const c = r * 2 * Math.PI;
                                            const p = currentRemaining / t.timerDuration;
                                            ring.style.strokeDashoffset = c - (p * c);
                                        }
                                    }
                                } else { // Timer has run out
                                    finishTimer(t.id); // Trigger the finish timer logic
                                }
                            }, 1000); // Update every second
                        } else { // Timer has already run out before resumeTimers was called
                            if (!t.timerFinished) { // Only process if not already marked as finished
                                t.timerFinished = true; // Mark as finished
                                delete t.timerStartTime; // Clean up properties
                                delete t.timerDuration;
                                needsSaveAndRender = true; // Mark that a save and re-render is needed
                            }
                        }
                    }
                });
                // Save and re-render if any timers were found to be expired upon resume
                if (needsSaveAndRender) {
                    saveState();
                    renderAllLists();
                }
            }
            
            // --- EVENT HANDLERS ---

            // Click handler for the main quests layout (tasks, groups, headers).
            document.querySelector('.quests-layout').addEventListener('click', (e) => {
                const taskItem = e.target.closest('.task-item');
                const groupHeader = e.target.closest('.main-quest-group-header');

                // Handler for showing/hiding action buttons on mobile
                function handleMobileActions(element) {
                     if (window.innerWidth > 1023) return; // Only for mobile screens
                     // If a button inside the actions wrapper was clicked, don't toggle actions visibility
                     if (e.target.closest('button')) { 
                         clearTimeout(actionsTimeoutId);
                         return;
                     }
                     clearTimeout(actionsTimeoutId); // Clear previous timeout
                     
                     const wasVisible = element.classList.contains('actions-visible');
                     // Toggle the 'actions-visible' class
                     element.classList.toggle('actions-visible');

                     if (!wasVisible) { // If actions were just made visible
                         activeMobileActionsItem = element; // Track the currently active item
                         // Set a timeout to automatically hide actions after a few seconds
                         actionsTimeoutId = setTimeout(() => {
                             if(element.classList.contains('actions-visible')) {
                                 element.classList.remove('actions-visible');
                                 activeMobileActionsItem = null; // Reset tracker
                             }
                         }, 3000); // Hide after 3 seconds
                     } else { // If actions were hidden by clicking again
                         activeMobileActionsItem = null; // Reset tracker
                     }
                }
                
                // Handle clicks on group headers
                if (groupHeader) { 
                    const groupId = groupHeader.parentElement.dataset.groupId;
                    const g = generalTaskGroups.find(g => g.id === groupId); // Find the group object

                    // Handle tap on expand icon specifically on mobile
                    if (window.innerWidth <= 1023 && e.target.closest('.expand-icon')) {
                        if (g) g.isExpanded = !g.isExpanded; // Toggle group expansion
                        saveState(); 
                        renderAllLists();
                        return; // Prevent the mobile actions menu from opening
                    }
                    
                    const isButton = e.target.closest('button'); // Check if a button was clicked
                    if (isButton) {
                        // Handle specific button actions within group header
                        if (e.target.closest('.add-task-to-group-btn')) { // Add task to this group
                            currentListToAdd = groupId; 
                            weeklyGoalContainer.style.display = 'none'; // Weekly goals only for daily tasks
                            addTaskModalTitle.textContent = `Add to "${g.name}"`; 
                            openModal(addTaskModal); 
                            focusOnDesktop(newTaskInput); 
                        } else if (e.target.closest('.delete-group-btn')) { // Delete group
                            deleteGroup(groupId);
                        }
                    } else { // If the header itself was clicked (not a button)
                         if (window.innerWidth <= 1023) { // On mobile, toggle action menu
                             handleMobileActions(groupHeader);
                         } else { // On desktop, toggle group expansion
                            if (g) g.isExpanded = !g.isExpanded; 
                            saveState(); 
                            renderAllLists();
                         }
                    }
                    return; // Exit after handling group header click
                }

                // Handle clicks on task items
                if (taskItem) {
                    const id = taskItem.dataset.id; // Get task ID
                    
                    // Handle tapping a completed daily task to uncomplete it
                    if (taskItem.classList.contains('daily-completed')) {
                        uncompleteDailyTask(id);
                        return; // Task handled, exit
                    }
                    
                    handleMobileActions(taskItem); // Manage mobile action visibility

                    // Handle clicks on buttons within the task item
                    if(e.target.closest('button')) {
                        currentEditingTaskId = id; // Store task ID for potential edits/timers
                        if (e.target.closest('.complete-btn')) { // Complete task button
                            completeTask(id);
                        } else if (e.target.closest('.delete-btn')) { // Delete task button
                            deleteTask(id);
                        } else if (e.target.closest('.timer-clock-btn')) { // Timer button
                            const { task } = findTaskAndContext(id); 
                            if (task && task.timerStartTime) { // If timer is already active
                                openModal(timerMenuModal); // Show menu to cancel timer
                            } else {
                                openModal(timerModal); // Show modal to set timer duration
                            }
                        } else if (e.target.closest('.edit-btn')) { // Edit task button
                            const { task, type } = findTaskAndContext(id);
                            if (task) {
                                editTaskIdInput.value = task.id; // Set hidden input for task ID
                                editTaskInput.value = task.text; // Populate input field with current text
                                // Update modal title and weekly goal UI based on task type
                                editTaskModal.querySelector('#edit-task-modal-title').textContent = (type === 'daily') ? 'Edit Daily Quest' : 'Edit Main Quest';
                                if (type === 'daily') {
                                    const goal = task.weeklyGoal || 0;
                                    editWeeklyGoalSlider.value = goal; // Set slider value
                                    updateGoalDisplay(editWeeklyGoalSlider, editWeeklyGoalDisplay); // Update display text
                                    editWeeklyGoalContainer.style.display = 'block'; // Show weekly goal controls
                                } else {
                                    editWeeklyGoalContainer.style.display = 'none'; // Hide weekly goal controls
                                }
                                openModal(editTaskModal); // Open the edit task modal
                                focusOnDesktop(editTaskInput); // Focus input field on desktop
                            }
                        }
                    }
                } 
            });

            // Form submission handlers
            addTaskForm.addEventListener('submit', (e) => { e.preventDefault(); const t = newTaskInput.value.trim(); if (t && currentListToAdd) { const goal = (currentListToAdd === 'daily') ? parseInt(weeklyGoalSlider.value, 10) : 0; addTask(t, currentListToAdd, goal); newTaskInput.value = ''; weeklyGoalSlider.value = 0; updateGoalDisplay(weeklyGoalSlider, weeklyGoalDisplay); closeModal(addTaskModal); } });
            editTaskForm.addEventListener('submit', (e) => { e.preventDefault(); const id = editTaskIdInput.value; const newText = editTaskInput.value.trim(); const newGoal = parseInt(editWeeklyGoalSlider.value, 10) || 0; if(id && newText) { editTask(id, newText, newGoal); closeModal(editTaskModal); } });
            timerForm.addEventListener('submit', (e) => { e.preventDefault(); const v = parseInt(timerDurationSlider.value,10), u = timerUnitSelector.querySelector('.selected').dataset.unit; let m = 0; // Calculate duration in minutes based on selected unit switch(u){ case 'seconds': m=v/60; break; case 'minutes': m=v; break; case 'hours': m=v*60; break; case 'days': m=v*1440; break; case 'weeks': m=v*10080; break; case 'months': m=v*43200; break; } if(m>0&&currentEditingTaskId){startTimer(currentEditingTaskId,m);closeModal(timerModal);currentEditingTaskId=null;} });
            timerMenuCancelBtn.addEventListener('click', () => { if (currentEditingTaskId) stopTimer(currentEditingTaskId); closeModal(timerMenuModal); });
            addGroupForm.addEventListener('submit', (e) => { e.preventDefault(); const n = newGroupInput.value.trim(); if (n) { addGroup(n); newGroupInput.value = ''; closeModal(addGroupModal); } });
            
            // Event listeners for modal triggers
            timerDurationSlider.addEventListener('input', () => timerDurationDisplay.textContent = timerDurationSlider.value); // Update duration display as slider moves
            timerUnitSelector.addEventListener('click', (e) => { // Handle unit selection for timer
                const t = e.target.closest('.timer-unit-btn');
                if (t) {
                    timerUnitSelector.querySelector('.selected').classList.remove('selected'); // Remove 'selected' from current button
                    t.classList.add('selected'); // Add 'selected' to the clicked button
                    playSound('toggle'); 
                } 
            });
            addTaskTriggerBtnDaily.addEventListener('click', () => { // Open modal for adding daily tasks
                currentListToAdd = 'daily'; 
                weeklyGoalContainer.style.display = 'block'; // Show weekly goal controls
                addTaskModalTitle.textContent = 'Add Daily Quest'; 
                openModal(addTaskModal); 
                focusOnDesktop(newTaskInput); 
            });
            addStandaloneTaskBtn.addEventListener('click', () => { // Open modal for adding standalone tasks
                currentListToAdd = 'standalone'; 
                weeklyGoalContainer.style.display = 'none'; // Hide weekly goal controls
                addTaskModalTitle.textContent = 'Add Main Quest'; 
                openModal(addTaskModal); 
                focusOnDesktop(newTaskInput); 
            });
            addGroupBtn.addEventListener('click', () => { // Open modal for adding task groups
                openModal(addGroupModal); 
                focusOnDesktop(newGroupInput); 
            });
            settingsBtn.addEventListener('click', () => openModal(settingsModal)); // Open settings modal

            // Generic modal close button handler
            document.querySelectorAll('[data-close-modal]').forEach(btn => btn.addEventListener('click', (e) => {
                const modalId = e.currentTarget.dataset.closeModal;
                const modal = document.getElementById(modalId);
                // Prevent closing persistent modals (like username setup) by clicking outside
                if (modal.getAttribute('data-persistent') !== 'true') {
                    closeModal(modal); // Use module-scoped closeModal
                    // Special handling for friends modal closing to restore mobile nav state
                    if (modalId === 'friends-modal') {
                        const activeBtn = mobileNav.querySelector(`.mobile-nav-btn.active`);
                        const prevSection = activeBtn ? activeBtn.dataset.section : 'daily'; // Default to daily if somehow no button is active
                        // Re-apply visibility based on the previously active mobile nav section
                        document.querySelectorAll('.task-group').forEach(group => {
                            group.classList.toggle('mobile-visible', group.dataset.section === prevSection);
                        });
                    }
                }
            }));
            
            // Add click-outside-to-close functionality to modals (except persistent ones)
            [addTaskModal, editTaskModal, addGroupModal, settingsModal, confirmModal, timerModal, accountModal, manageAccountModal, document.getElementById('username-modal'), googleLoaderModal, friendsModal].forEach(m => { 
                if (m) { // Ensure the modal element exists
                    m.addEventListener('click', (e) => { 
                        // Close modal if clicked element is the overlay itself and modal is not persistent
                        if (e.target === m && m.getAttribute('data-persistent') !== 'true') {
                            closeModal(m); // Use module-scoped closeModal
                        }
                    }); 
                }
            });

            // Function to show a confirmation prompt before an action.
            function showConfirm(title, text, cb) { 
                confirmTitle.textContent = title; 
                confirmText.textContent = text; 
                confirmCallback = cb; // Store the callback function
                openModal(confirmModal); // Use module-scoped openModal
            }
            // Action for confirming the confirmation modal.
            confirmActionBtn.addEventListener('click', () => { 
                if (confirmCallback) confirmCallback(); // Execute the stored callback
                closeModal(confirmModal); // Close the confirmation modal
            });
            confirmCancelBtn.addEventListener('click', () => closeModal(confirmModal)); // Close confirmation modal without action

            // Applies theme and accent color settings to the document.
            const applySettings = () => { 
                document.documentElement.style.setProperty('--accent', settings.accentColor); // Set accent color CSS variable
                // Update selected state for color swatches
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.toggle('selected', s.dataset.color === settings.accentColor)); 
                
                // Ensure volume slider is set
                if(typeof settings.volume==='undefined') settings.volume=0.3; // Default volume if not set
                volumeSlider.value = settings.volume; 
                
                // Determine system dark mode preference
                const d = window.matchMedia('(prefers-color-scheme: dark)').matches;
                // Add/remove 'dark-mode' class based on theme setting and system preference
                document.documentElement.classList.toggle('dark-mode', settings.theme === 'dark' || (settings.theme === 'system' && d)); 
                
                // Update selected state for theme buttons
                document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('selected'));
                const selectedThemeBtn = document.querySelector(`.theme-btn[data-theme="${settings.theme}"]`);
                if(selectedThemeBtn) selectedThemeBtn.classList.add('selected');
            };

            // Event listener for theme selection buttons.
            themeOptionsButtons.addEventListener('click', (e) => { 
                const t = e.target.closest('.theme-btn');
                if (t) { 
                    settings.theme = t.dataset.theme; // Update theme setting
                    saveState(); // Save the setting
                    applySettings(); // Apply the theme immediately
                    playSound('toggle'); 
                } 
            });
            // Event listener for accent color selection.
            colorOptions.addEventListener('click', (e) => { 
                if(e.target.classList.contains('color-swatch')) {
                    settings.accentColor = e.target.dataset.color; // Update accent color setting
                    saveState(); // Save the setting
                    applySettings(); // Apply the color immediately
                } 
            });
            // Event listener for volume slider.
            volumeSlider.addEventListener('input', () => { 
                settings.volume = parseFloat(volumeSlider.value); // Update volume setting
                saveState(); // Save the setting
            });
            volumeSlider.addEventListener('change', () => playSound('toggle')); // Play sound when volume changes significantly
            
            // Helper to update the display text for the weekly goal slider.
            function updateGoalDisplay(slider, display) {
                const value = slider.value;
                if (value === '0') {
                    display.textContent = 'None';
                } else {
                    display.textContent = `${value} day${value > 1 ? 's' : ''}`;
                }
            }
            // Add listeners for weekly goal sliders in add/edit task modals.
            weeklyGoalSlider.addEventListener('input', () => updateGoalDisplay(weeklyGoalSlider, weeklyGoalDisplay));
            editWeeklyGoalSlider.addEventListener('input', () => updateGoalDisplay(editWeeklyGoalSlider, editWeeklyGoalDisplay));
            
            // Reset progress button handler.
            resetProgressBtn.addEventListener('click', () => showConfirm('Reset all progress?', 'This cannot be undone. All your tasks, progress, and settings will be lost.', () => { 
                // Reset all state variables to defaults
                playerData = { level: 1, xp: 0 }; 
                dailyTasks = []; 
                standaloneMainQuests = []; 
                generalTaskGroups = []; 
                settings = { theme: 'system', accentColor: 'var(--accent-red)', volume: 0.3 }; // Reset settings too
                renderAllLists(); 
                applySettings(); // Re-apply settings after reset
                saveState(); // Save the reset state
                playSound('delete'); 
            }));
            
            // Export guest data button handler.
            exportDataBtn.addEventListener('click', () => { 
                const d = localStorage.getItem('anonymousUserData'); // Get data from local storage
                const blob = new Blob([d || '{}'], {type: "application/json"}); // Create blob
                const url = URL.createObjectURL(blob); // Create object URL
                const a = document.createElement("a"); 
                a.href = url; 
                a.download = `procrasti-nope_guest_backup_${Date.now()}.json`; // Set filename
                a.click(); // Simulate click to trigger download
                URL.revokeObjectURL(url); // Clean up object URL
            });
            // Import guest data button handler (triggers file input).
            importDataBtn.addEventListener('click', () => importFileInput.click());
            // File input change handler for importing guest data.
            importFileInput.addEventListener('change', (e) => { 
                const f = e.target.files[0]; 
                if(!f) return; 
                showConfirm("Import Guest Data?", "This will overwrite your current guest data. Are you sure?", () => { 
                    const reader = new FileReader(); 
                    reader.onload = (event) => { 
                        try {
                            localStorage.setItem('anonymousUserData', event.target.result); // Save imported data
                            // Reload necessary parts of the app after import
                            const loadedData = JSON.parse(event.target.result);
                            loadAndDisplayData(loadedData); // Load and display the imported data
                            saveState(); // Save state to ensure it's debounced/written correctly
                        } catch (error) {
                            console.error("Error importing data:", error);
                            alert("Failed to import data. The file might be corrupted or not valid JSON.");
                        }
                    }; 
                    reader.readAsText(f); // Read the file as text
                }); 
                e.target.value = ''; // Clear the file input value to allow re-importing the same file
            });

            // Play a quiet sound on hover for interactive elements.
            document.body.addEventListener('mouseover', e => { 
                const t = e.target.closest('.btn, .color-swatch, .complete-btn, .main-title, .task-item, .main-quest-group-header'); // Elements that should trigger hover sound
                if (!t || (e.relatedTarget && t.contains(e.relatedTarget))) return; // Avoid double triggers or when leaving an element
                playSound('hover'); 
            });
            
            // --- ACCOUNT MANAGEMENT HANDLERS ---
            
            // Opens the manage account modal.
            manageAccountBtn.addEventListener('click', () => {
                const reauthContainer = manageAccountModal.querySelector('#reauth-container');
                const manageFormsContainer = manageAccountModal.querySelector('#manage-forms-container');
                // Check if the user is logged in via Google (they don't need password re-auth for username change).
                const isGoogleUser = currentUser && currentUser.providerData.some(p => p.providerId === 'google.com');

                // Reset form states for security and usability.
                manageAccountModal.querySelectorAll('.error-message, .success-message').forEach(el => el.textContent = '');
                manageAccountModal.querySelectorAll('form').forEach(form => form.reset());

                if (isGoogleUser) {
                    reauthContainer.style.display = 'none'; // Hide password confirmation
                    manageFormsContainer.style.display = 'block'; // Show management forms
                    // For Google users, only username change is directly available without re-auth. Email/password changes require re-auth.
                    manageAccountModal.querySelector('#update-email-form').style.display = 'none';
                    manageAccountModal.querySelector('#update-password-form').style.display = 'none';
                    manageAccountModal.querySelector('#update-username-form').style.display = 'block';
                } else { // For email/password users
                    reauthContainer.style.display = 'block'; // Show password confirmation
                    manageFormsContainer.style.display = 'none'; // Hide management forms until re-authenticated
                    // Ensure all forms are potentially visible after re-auth
                    manageAccountModal.querySelector('#update-email-form').style.display = 'block';
                    manageAccountModal.querySelector('#update-password-form').style.display = 'block';
                    manageAccountModal.querySelector('#update-username-form').style.display = 'block';
                }
                openModal(manageAccountModal); // Open the manage account modal
            });

            // Form handler for re-authenticating the user with their password.
            const reauthForm = document.getElementById('reauth-form');
            reauthForm.addEventListener('submit', async(e) => {
                e.preventDefault();
                const password = document.getElementById('reauth-password').value;
                const errorEl = document.getElementById('reauth-error');
                errorEl.textContent = '';

                if (!currentUser || !currentUser.email) { // Should not happen if called correctly, but safety check
                    errorEl.textContent = 'No user is currently logged in.';
                    return;
                }

                // Create Firebase credential object
                const credential = window.firebaseSDK.EmailAuthProvider.credential(currentUser.email, password);

                try {
                    await window.firebaseSDK.reauthenticateWithCredential(currentUser, credential);
                    // On successful re-authentication, show the account management forms.
                    document.getElementById('reauth-container').style.display = 'none';
                    document.getElementById('manage-forms-container').style.display = 'block';
                } catch (error) {
                    errorEl.textContent = getCoolErrorMessage(error); // Display error message
                }
            });

            // Form handler for updating the user's email address.
            const updateEmailForm = document.getElementById('update-email-form');
            updateEmailForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newEmail = document.getElementById('update-email-input').value;
                const password = document.getElementById('update-email-password').value; // Current password required for update
                const errorEl = document.getElementById('update-email-error');
                const successEl = document.getElementById('update-email-success');
                errorEl.textContent = ''; // Clear previous errors
                successEl.textContent = ''; // Clear previous success messages

                if (!password) { // Password is required for email/password updates
                    errorEl.textContent = 'Please enter your current password.';
                    return;
                }

                try {
                    // Re-authenticate before performing the sensitive update operation.
                    const credential = window.firebaseSDK.EmailAuthProvider.credential(currentUser.email, password);
                    await window.firebaseSDK.reauthenticateWithCredential(currentUser, credential);

                    // Update email in Firebase Authentication service.
                    await window.firebaseSDK.updateEmail(currentUser, newEmail);
                    
                    // Update email in Firestore user document as well.
                    const userDocRef = window.firebaseSDK.doc(db, "users", currentUser.uid);
                    await window.firebaseSDK.updateDoc(userDocRef, { email: newEmail });

                    successEl.textContent = 'Email updated successfully!'; // Show success message
                    updateEmailForm.reset(); // Reset the form fields

                } catch (error) {
                    errorEl.textContent = getCoolErrorMessage(error); // Display error
                }
            });

            // Form handler for updating the user's password.
            const updatePasswordForm = document.getElementById('update-password-form');
            updatePasswordForm.addEventListener('submit', async(e) => {
                e.preventDefault();
                const newPassword = document.getElementById('update-password-input').value;
                const errorEl = document.getElementById('update-password-error');
                const successEl = document.getElementById('update-password-success');
                errorEl.textContent = ''; // Clear errors
                successEl.textContent = ''; // Clear success messages

                try {
                    await window.firebaseSDK.updatePassword(currentUser, newPassword);
                    successEl.textContent = 'Password updated successfully!'; // Show success
                    updatePasswordForm.reset(); // Reset form
                } catch (error) {
                     errorEl.textContent = getCoolErrorMessage(error); // Display error
                }
            });

            // Form handler for updating the user's username.
            const updateUsernameForm = document.getElementById('update-username-form');
            updateUsernameForm.addEventListener('submit', async(e) => {
                e.preventDefault();
                const newUsername = document.getElementById('update-username-input').value.trim().toLowerCase();
                const errorEl = document.getElementById('update-username-error');
                const successEl = document.getElementById('update-username-success');
                errorEl.textContent = ''; // Clear errors
                successEl.textContent = ''; // Clear success messages

                if (!currentUser) { // Safety check
                    errorEl.textContent = "You must be logged in.";
                    return;
                }
                
                // Basic username validation
                if (!newUsername || newUsername.length < 3) {
                    errorEl.textContent = 'Username must be at least 3 characters.';
                    return;
                }

                try {
                    const userDocRef = window.firebaseSDK.doc(db, "users", currentUser.uid);
                    const userDocSnap = await window.firebaseSDK.getDoc(userDocRef);
                    const currentUsername = userDocSnap.exists() ? userDocSnap.data().username : null;

                    // If username hasn't changed, do nothing.
                    if (newUsername === currentUsername) {
                        errorEl.textContent = "This is already your username.";
                        return;
                    }
                    
                    // Check if the new username is already taken.
                    const newUsernameRef = window.firebaseSDK.doc(db, "usernames", newUsername);
                    const newUsernameSnap = await window.firebaseSDK.getDoc(newUsernameRef);
                    
                    if (newUsernameSnap.exists()) {
                        errorEl.textContent = "This username is already taken.";
                        return;
                    }

                    // Use a batch write to atomically update username and delete the old username entry.
                    const batch = window.firebaseSDK.writeBatch(db);
                    // Delete the old username entry if it exists.
                    if (currentUsername) {
                        const oldUsernameRef = window.firebaseSDK.doc(db, "usernames", currentUsername);
                        batch.delete(oldUsernameRef);
                    }
                    // Add the new username entry.
                    batch.set(newUsernameRef, { userId: currentUser.uid });
                    // Update the user's document with the new username.
                    batch.update(userDocRef, { username: newUsername });
                    await batch.commit(); // Commit the batch operation

                    successEl.textContent = "Username updated successfully!"; // Show success message
                    updateUserUI(); // Refresh the user display in settings and potentially elsewhere
                    updateUsernameForm.reset(); // Reset the form
                } catch (error) {
                    errorEl.textContent = getCoolErrorMessage(error); // Display error
                }
            });
            
            // Initializes SortableJS for drag-and-drop functionality on task lists.
            function initSortable() {
                // Callback function when a task is dropped in a new location.
                function onTaskDrop(evt) {
                    document.body.classList.remove('is-dragging'); // Remove dragging class from body
                    const taskId = evt.item.dataset.id; // Get the ID of the dragged task item
                    if (!taskId) return; // If no task ID, exit
                    
                    // Find the task and its source list.
                    const { task, list: sourceListArray } = findTaskAndContext(taskId);
                    if (!task || !sourceListArray) return; // Exit if task or list not found
                    
                    const originalIndex = sourceListArray.findIndex(t => t.id === taskId); // Find original index
                    if (originalIndex > -1) sourceListArray.splice(originalIndex, 1); // Remove task from its original position
                    else return; // Should not happen, but exit if original index not found

                    const toListEl = evt.to; // The target list element
                    const toListId = toListEl.id; // ID of the target list (e.g., 'daily-task-list')
                    const toGroupId = toListEl.dataset.groupId; // Group ID if target is a group's task list
                    let destListArray; // Array where the task will be placed

                    // Determine the destination list array based on the target element
                    if (toListId === 'daily-task-list') destListArray = dailyTasks;
                    else if (toListId === 'standalone-task-list') destListArray = standaloneMainQuests;
                    else if (toGroupId) { // Target is a task list within a group
                        const group = generalTaskGroups.find(g => g.id === toGroupId);
                        if (group) {
                            if (!group.tasks) group.tasks = []; // Ensure tasks array exists
                            destListArray = group.tasks;
                        }
                    }

                    // If destination list couldn't be determined, put the task back in its original list.
                    if (!destListArray) {
                        sourceListArray.splice(originalIndex, 0, task); // Re-insert at original index
                        return;
                    }
                    
                    // Insert the task into the destination list at the new index.
                    destListArray.splice(evt.newIndex, 0, task);
                    
                    saveState(); // Save the new order
                    renderAllLists(); // Re-render to update UI and potentially remove empty groups
                }

                // Common options for SortableJS instances
                const commonTaskOptions = {
                    animation: 150, // Animation speed
                    delay: 500, // Delay before dragging starts
                    delayOnTouchOnly: true, // Apply delay only on touch devices
                    onStart: () => document.body.classList.add('is-dragging'), // Add class when dragging starts
                    onEnd: onTaskDrop // Use the custom drop handler
                };

                // Initialize Sortable for daily tasks
                new Sortable(dailyTaskListContainer, { ...commonTaskOptions, group: 'dailyQuests' }); 
                // Initialize Sortable for standalone tasks
                new Sortable(standaloneTaskListContainer, { ...commonTaskOptions, group: 'mainQuests' });
                // Initialize Sortable for tasks within each general group
                document.querySelectorAll('.task-list-group').forEach(listEl => {
                    new Sortable(listEl, { ...commonTaskOptions, group: 'mainQuests' });
                });
                // Initialize Sortable for the general task groups themselves (reordering groups)
                new Sortable(generalTaskListContainer, {
                    animation: 150,
                    handle: '.main-quest-group-header', // Drag only by the header
                    delay: 500,
                    delayOnTouchOnly: true,
                    onStart: () => document.body.classList.add('is-dragging'),
                    onEnd: (e) => { // Handler for dropping a group
                        document.body.classList.remove('is-dragging');
                        // Reorder the generalTaskGroups array based on the drag-and-drop event
                        const [item] = generalTaskGroups.splice(e.oldIndex, 1); // Remove group from old position
                        generalTaskGroups.splice(e.newIndex, 0, item); // Insert group at new position
                        saveState(); // Save the new order
                    }
                });
            }

            // Creates a confetti effect at a specific element's location.
            function createConfetti(el) { 
                if(!el) return; // Do nothing if element is null
                const rect = el.getBoundingClientRect(); // Get element's position and size
                // Trigger full-screen confetti if 'party' is true, otherwise confetti at element's center.
                createFullScreenConfetti(false, { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }); 
            }

            // Creates a full-screen confetti effect.
            function createFullScreenConfetti(party, origin = null) {
                const numPieces = party ? 200 : 100; // More pieces for 'party mode'
                for (let i = 0; i < numPieces; i++) {
                    const c = document.createElement('div'); 
                    c.className = 'confetti';
                    // Set initial position: random screen position or from provided origin
                    const sx = origin ? origin.x : Math.random()*window.innerWidth;
                    const sy = origin ? origin.y : -20; // Start slightly above the viewport
                    c.style.left=`${sx}px`; 
                    c.style.top=`${sy}px`; 
                    // Assign a random color from the accent palette
                    c.style.backgroundColor = ['var(--accent-pink)','var(--accent-blue)','var(--accent-green)','var(--accent-orange)','var(--accent-purple)'][Math.floor(Math.random()*5)];
                    document.body.appendChild(c); // Add confetti element to the body

                    // Animate the confetti piece
                    const angle = Math.random()*Math.PI*2; // Random angle
                    const velocity = 50+Math.random()*100; // Random velocity
                    const exitX = Math.cos(angle)*velocity*(Math.random()*5); // Horizontal exit trajectory
                    const exitY = (Math.sin(angle)*velocity)+(window.innerHeight-sy); // Vertical exit trajectory (falls downwards)
                    
                    c.animate([
                        {transform:'translate(0,0) rotate(0deg)',opacity:1}, // Start state
                        {transform:`translate(${exitX}px, ${exitY}px) rotate(${Math.random()*720}deg)`,opacity:0} // End state (fades out and moves)
                    ],{
                        duration:3000+Math.random()*2000, // Random duration between 3-5 seconds
                        easing:'cubic-bezier(0.1,0.5,0.5,1)' // Easing function for realistic fall
                    }).onfinish = () => c.remove(); // Remove element from DOM after animation finishes
                }
                // If in party mode, add a temporary background overlay animation
                if(party){
                    const p = document.createElement('div');
                    p.className='party-time-overlay';
                    document.body.appendChild(p);
                    setTimeout(() => p.remove(), 5000); // Remove overlay after 5 seconds
                }
            }

            // Renders all task lists and groups, then re-initializes sortable and resumes timers.
            const renderAllLists = () => { 
                renderDailyTasks(); 
                renderStandaloneTasks(); 
                renderGeneralTasks(); 
                checkOverdueTasks(); // Re-check overdue status after rendering
                initSortable(); // Re-initialize sortable after DOM updates
                resumeTimers(); // Ensure timers are running correctly after render
            };
            
            // Event listener for the "Login / Sign Up" button in the settings modal.
            settingsLoginBtn.addEventListener('click', () => {
                const accountModalContent = accountModal.querySelector('.modal-content');
                // Set up the auth forms within the account modal.
                setupAuthForms(accountModalContent, () => {
                    closeModal(accountModal); // Close account modal on auth success
                    closeModal(settingsModal); // Close settings modal too
                });
                openModal(accountModal); // Open the account modal
            });

            // Event listener for the logout button.
            logoutBtn.addEventListener('click', () => {
                showConfirm("Logout?", "Are you sure you want to log out? You will be returned to the landing page.", () => {
                    closeModal(settingsModal); // Close settings modal
                    sessionStorage.removeItem('isGuest'); // Clear guest session flag
                    // Sign out from Firebase Auth. Catch potential errors.
                    window.firebaseSDK.signOut(auth).catch(error => console.error("Logout Error:", getCoolErrorMessage(error)));
                });
            });
            
            
            // =========================================================================
            // FRIENDS FEATURE LOGIC
            // =========================================================================

            /**
             * Sets up a real-time listener for the current user's friend requests.
             * This is efficient as it only listens to one document for updates.
             * It updates the UI with a notification badge if there are pending requests.
             */
            function listenForFriendRequests() {
                if (!user) return; // Only run if a user is logged in
                // Unsubscribe from any previous listener to prevent multiple listeners.
                if (unsubscribeFromFriends) unsubscribeFromFriends();
                
                const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                // Set up the snapshot listener.
                unsubscribeFromFriends = window.firebaseSDK.onSnapshot(userDocRef, (doc) => {
                    if (doc.exists()) {
                        const requests = doc.data().friendRequests || [];
                        // Update badge visibility and count
                        if (requests.length > 0) {
                            friendRequestCountBadge.textContent = requests.length;
                            friendRequestCountBadge.style.display = 'inline';
                        } else {
                            friendRequestCountBadge.style.display = 'none';
                        }
                    }
                }, (error) => { // Error handler for the listener
                    console.error("Error listening to friend requests: ", getCoolErrorMessage(error));
                });
            }

            /**
             * Fetches and renders the current user's friends list and pending requests.
             * This is called on-demand when the friends modal is opened.
             */
            async function renderFriendsAndRequests() {
                if (!user) return; // Ensure user is logged in
                
                const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                const userDoc = await window.firebaseSDK.getDoc(userDocRef);
                if (!userDoc.exists()) return; // Exit if user document doesn't exist

                const userData = userDoc.data();
                const friendUIDs = userData.friends || []; // Get list of friend UIDs
                const requestUIDs = userData.friendRequests || []; // Get list of pending request UIDs
                
                // Render Friends List
                if (friendUIDs.length === 0) {
                    friendsListContainer.innerHTML = `<p style="text-align: center; padding: 1rem;">Go add some friends!</p>`;
                } else {
                    friendsListContainer.innerHTML = ''; // Clear previous list
                    // Fetch multiple friend documents efficiently using a 'where in' query
                    const friendsQuery = window.firebaseSDK.query(window.firebaseSDK.collection(db, "users"), window.firebaseSDK.where(window.firebaseSDK.documentId(), 'in', friendUIDs));
                    const friendDocs = await window.firebaseSDK.getDocs(friendsQuery);
                    friendDocs.forEach(doc => { // Iterate through friend documents
                         const friend = doc.data();
                         const level = friend.appData?.playerData?.level || 1; // Get friend's level, default to 1
                         const friendEl = document.createElement('div');
                         friendEl.className = 'friend-item';
                         friendEl.innerHTML = `
                            <div class="friend-level-display">LVL ${level}</div>
                            <span class="friend-name">${friend.username}</span>
                            <div class="friend-item-actions">
                                <button class="btn icon-btn remove-friend-btn" data-uid="${doc.id}" aria-label="Remove friend">&times;</button>
                            </div>`;
                         friendsListContainer.appendChild(friendEl); // Add friend item to the list
                    });
                }

                // Render Requests List
                if (requestUIDs.length === 0) {
                    friendRequestsContainer.innerHTML = `<p style="text-align: center; padding: 1rem;">No new requests.</p>`;
                } else {
                    friendRequestsContainer.innerHTML = ''; // Clear previous list
                    // Fetch documents for users who sent requests
                    const requestsQuery = window.firebaseSDK.query(window.firebaseSDK.collection(db, "users"), window.firebaseSDK.where(window.firebaseSDK.documentId(), 'in', requestUIDs));
                    const requestDocs = await window.firebaseSDK.getDocs(requestsQuery);
                    requestDocs.forEach(doc => { // Iterate through request documents
                        const requestUser = doc.data();
                        const requestEl = document.createElement('div');
                        requestEl.className = 'friend-request-item';
                        requestEl.innerHTML = `
                            <span>${requestUser.username}</span>
                            <div class="friend-request-actions">
                                <button class="btn icon-btn accept-request-btn" data-uid="${doc.id}" aria-label="Accept request">&#10003;</button>
                                <button class="btn icon-btn decline-request-btn" data-uid="${doc.id}" aria-label="Decline request">&times;</button>
                            </div>`;
                        friendRequestsContainer.appendChild(requestEl); // Add request item to the list
                    });
                }
            }
            
            /** Handles sending a friend request */
            async function handleAddFriend(e) {
                e.preventDefault();
                const usernameToFind = searchUsernameInput.value.trim().toLowerCase();
                friendStatusMessage.textContent = ''; // Clear previous status messages
                
                if (!user || !usernameToFind) return; // Basic validation

                // Get current user's data to check against self-adding
                const currentUserDoc = await window.firebaseSDK.getDoc(window.firebaseSDK.doc(db, "users", user.uid));
                if (usernameToFind === currentUserDoc.data().username) {
                    friendStatusMessage.textContent = "You can't add yourself!";
                    friendStatusMessage.style.color = 'var(--accent-red-light)';
                    return;
                }
                
                // Efficiently check if the username exists using the 'usernames' collection.
                const usernamesRef = window.firebaseSDK.doc(db, "usernames", usernameToFind);
                const usernameSnap = await window.firebaseSDK.getDoc(usernamesRef);

                if (!usernameSnap.exists()) { // If username not found
                    friendStatusMessage.textContent = "User not found.";
                    friendStatusMessage.style.color = 'var(--accent-red-light)';
                    return;
                }
                
                const targetUserId = usernameSnap.data().userId; // Get the UID of the target user
                const targetUserDocRef = window.firebaseSDK.doc(db, "users", targetUserId);
                
                // Use a transaction (or batch write) to safely add the request to the target user's document.
                try {
                    await window.firebaseSDK.updateDoc(targetUserDocRef, {
                        // Use arrayUnion to add the current user's UID to the target's friendRequests array.
                        friendRequests: window.firebaseSDK.arrayUnion(user.uid) 
                    });
                    friendStatusMessage.textContent = `Friend request sent to ${usernameToFind}!`;
                    friendStatusMessage.style.color = 'var(--accent-green-light)';
                    searchUsernameInput.value = ''; // Clear the input field
                } catch (error) {
                    friendStatusMessage.textContent = "Could not send request.";
                    friendStatusMessage.style.color = 'var(--accent-red-light)';
                    console.error("Error sending friend request:", getCoolErrorMessage(error));
                }
            }
            
            /** Handles accepting or declining a friend request */
            async function handleRequestAction(e, action) {
                const button = e.target.closest('button');
                if (!button) return;

                const senderUid = button.dataset.uid; // UID of the user who sent the request
                const currentUserRef = window.firebaseSDK.doc(db, "users", user.uid);
                
                // Use a batch write for atomic updates.
                const batch = window.firebaseSDK.writeBatch(db);
                // Always remove the request from the current user's friendRequests list.
                batch.update(currentUserRef, { friendRequests: window.firebaseSDK.arrayRemove(senderUid) });

                if (action === 'accept') { // If request is accepted
                    const senderUserRef = window.firebaseSDK.doc(db, "users", senderUid);
                    // Add each other to their respective 'friends' lists.
                    batch.update(currentUserRef, { friends: window.firebaseSDK.arrayUnion(senderUid) });
                    batch.update(senderUserRef, { friends: window.firebaseSDK.arrayUnion(user.uid) });
                }
                
                await batch.commit(); // Execute the batch write
                renderFriendsAndRequests(); // Re-render the lists to reflect changes
            }
            
            /** Handles removing a friend */
            async function removeFriend(e) {
                const button = e.target.closest('button');
                if (!button) return;
                const friendUidToRemove = button.dataset.uid; // UID of the friend to remove
                
                // Show confirmation dialog before proceeding.
                showConfirm("Remove Friend?", "Are you sure you want to remove this friend? This action cannot be undone.", async () => {
                    const currentUserRef = window.firebaseSDK.doc(db, "users", user.uid);
                    const friendUserRef = window.firebaseSDK.doc(db, "users", friendUidToRemove);
                    
                    // Use batch write to remove each other from friends lists.
                    const batch = window.firebaseSDK.writeBatch(db);
                    batch.update(currentUserRef, { friends: window.firebaseSDK.arrayRemove(friendUidToRemove) });
                    batch.update(friendUserRef, { friends: window.firebaseSDK.arrayRemove(user.uid) });
                    
                    await batch.commit(); // Execute batch
                    renderFriendsAndRequests(); // Re-render lists
                });
            }

            // Event Listeners for Friends Modal interactions
            friendsBtnDesktop.addEventListener('click', () => { // Click on desktop friends button
                openModal(friendsModal); // Open the friends modal
                renderFriendsAndRequests(); // Render the content (friends, requests, add friend form)
            });
            
            addFriendForm.addEventListener('submit', handleAddFriend); // Handle submitting the add friend form
            
            // Event delegation for accepting/declining requests in the requests tab.
            friendRequestsContainer.addEventListener('click', e => {
                 if (e.target.closest('.accept-request-btn')) handleRequestAction(e, 'accept');
                 if (e.target.closest('.decline-request-btn')) handleRequestAction(e, 'decline');
            });
            
            // Event delegation for removing friends in the friends list tab.
            friendsListContainer.addEventListener('click', e => {
                if (e.target.closest('.remove-friend-btn')) removeFriend(e);
            });
            
            // Handler for switching tabs within the friends modal.
            friendsModal.querySelector('.form-toggle').addEventListener('click', (e) => {
                if (e.target.matches('.toggle-btn')) { // If a toggle button was clicked
                    const tab = e.target.dataset.tab; // Get the target tab ID
                    // Update active state of buttons
                    friendsModal.querySelectorAll('.toggle-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    // Show/hide tab content panes
                    friendsModal.querySelectorAll('.tab-content').forEach(form => form.classList.toggle('active', form.id === `${tab}-tab`));
                }
            });

            // =========================================================================
            // MOBILE NAVIGATION LOGIC
            // =========================================================================
            mobileNav.addEventListener('click', (e) => {
                const button = e.target.closest('.mobile-nav-btn'); // Find the clicked button
                if (!button) return; // Exit if not a button click

                const section = button.dataset.section; // Get the section associated with the button
                
                // Track the last viewed section that is not 'friends', to return to it after closing friends modal.
                if (section !== 'friends') {
                    lastSection = section;
                }

                // Update active state of navigation buttons
                mobileNav.querySelectorAll('.mobile-nav-btn').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                if (section === 'friends') { // If 'Friends' button is clicked
                    openModal(friendsModal); // Open the friends modal
                    renderFriendsAndRequests(); // Render its content
                } else { // For other sections (Daily, Main)
                    // Toggle visibility of task groups based on the selected section
                    document.querySelectorAll('.task-group').forEach(group => {
                        group.classList.toggle('mobile-visible', group.dataset.section === section);
                    });
                }
                playSound('toggle'); // Play toggle sound
            });

            // Account Deletion Logic
            deleteAccountBtn.addEventListener('click', () => {
                showConfirm('Delete Account?', 'This action is irreversible and will permanently delete your account and all associated data. Are you sure?', async () => {
                    try {
                        // Check if the user logged in with Google
                        const isGoogleUser = currentUser && currentUser.providerData.some(p => p.providerId === 'google.com');
                        
                        // If not a Google user, require password re-authentication first.
                        if (!isGoogleUser) {
                           const password = document.getElementById('reauth-password').value; // Get password from reauth form
                           if (!password) { // Ensure password was entered
                                alert("Please re-authenticate with your password before deleting.");
                                return;
                           }
                           const credential = window.firebaseSDK.EmailAuthProvider.credential(currentUser.email, password);
                           await window.firebaseSDK.reauthenticateWithCredential(currentUser, credential);
                        }

                        // Get the username before deleting the user document for potential cleanup.
                        const userDocRef = window.firebaseSDK.doc(db, "users", currentUser.uid);
                        const userDocSnap = await window.firebaseSDK.getDoc(userDocRef);
                        const username = userDocSnap.exists() ? userDocSnap.data().username : null;

                        // Use a batch write to delete user-related data atomically.
                        const batch = window.firebaseSDK.writeBatch(db);
                        batch.delete(userDocRef); // Delete user's main document
                        if (username) { // If username exists, delete the corresponding entry in 'usernames' collection
                            const usernameDocRef = window.firebaseSDK.doc(db, "usernames", username);
                            batch.delete(usernameDocRef);
                        }
                        await batch.commit(); // Commit the batch

                        // Delete the user from Firebase Authentication service.
                        await window.firebaseSDK.deleteUser(currentUser);
                        
                        closeModal(manageAccountModal); // Close the manage account modal
                        // Sign out and reload the page to fully reflect the deletion.
                        window.firebaseSDK.signOut(auth);
                        window.location.reload(); 
                    } catch (error) {
                        console.error("Error deleting account:", error);
                        // Display error message appropriately (e.g., in the reauth form's error field).
                        const errorEl = document.getElementById('reauth-error'); // Assuming error occurs during reauth or deletion
                        if(errorEl) errorEl.textContent = getCoolErrorMessage(error);
                        else alert(`Error deleting account: ${getCoolErrorMessage(error)}`);
                    }
                });
            });


            // Main function to load user session data and initialize the UI.
            async function loadUserSession() {
                await initialLoad(); // Load tasks, player data, settings etc.
                await updateUserUI(); // Update UI based on logged-in status
                await promptForUsernameIfNeeded(); // Prompt for username if necessary
                await updateUserUI(); // Update UI again in case username was set
                checkDailyReset(); // Perform daily reset logic
                resumeTimers(); // Ensure timers are running
            }
            
            // One-time initialization tasks.
            const initOnce = () => {
                // Add listener for system theme changes.
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applySettings);
                showRandomQuote(); // Display a random quote on load.
                // Set interval to check for overdue tasks periodically.
                setInterval(checkOverdueTasks, 60 * 1000); // Check every minute
            };

            initOnce(); // Run one-time initializations.
            await loadUserSession(); // Load user session data and finalize setup.

            // Return the app controller object with methods to manage the app's state.
            return {
                isPartial: false, // Indicates full initialization
                // shutdown function to clean up listeners and intervals when the app is unloaded or user logs out.
                shutdown: () => {
                     Object.keys(activeTimers).forEach(id => clearInterval(activeTimers[id])); // Clear all active timers
                     if (unsubscribeFromFirestore) unsubscribeFromFirestore(); // Clean up Firestore listener
                     if (unsubscribeFromFriends) unsubscribeFromFriends(); // Clean up friends listener
                },
                // updateUser function to re-initialize the app logic when the user state changes.
                updateUser: async (newUser) => {
                    user = newUser; // Update the user reference
                    await loadUserSession(); // Reload session data for the new user state
                }
            };
        }

        // =========================================================================
        // UTILITY/SHARED AUTH FUNCTIONS
        // =========================================================================

        /**
         * Provides user-friendly error messages for common Firebase authentication errors.
         * @param {Error} error The Firebase error object.
         * @returns {string} A user-friendly error message.
         */
        function getCoolErrorMessage(error) {
            const defaultMessage = "An unexpected vortex appeared! Please try again."; // Default generic error
            if (!error) return defaultMessage;

            // Check for specific Firestore permission errors first.
            if (error.message && error.message.toLowerCase().includes("missing or insufficient permissions")) {
                return "Permission Denied! Check your Firestore Security Rules.";
            }
            if (error.code === 'permission-denied') {
                 return "Permission Denied! Please check your Firestore Security Rules in the Firebase console.";
            }

            // Handle common Firebase Auth error codes.
            switch (error.code) {
                case 'auth/invalid-email': return "Hmm, that email doesn't look right. Check for typos?";
                case 'auth/user-disabled': return "This account has been disabled. Contact support for help.";
                case 'auth/user-not-found': return "No account found with this email or username. Time to sign up?";
                case 'auth/wrong-password': return "Incorrect password. Did you forget? It happens to the best of us!";
                case 'auth/email-already-in-use': return "An account with this email already exists. Try logging in!";
                case 'auth/weak-password': return "Password should be at least 6 characters long. Make it strong!";
                case 'auth/requires-recent-login': return "This is a sensitive action. Please log in again to continue.";
                case 'auth/popup-closed-by-user': return "Sign-in cancelled. Did you change your mind?";
                case 'auth/account-exists-with-different-credential': return "You've already signed up with this email using a different method (e.g., Google). Try logging in that way!";
                case 'auth/too-many-requests': return "You have made too many sign-in attempts. Please wait a bit before trying again.";
                case 'auth/invalid-credential': return "Invalid login credentials. Please check your username and password.";
                default: // Log unexpected errors to the console for debugging.
                    console.error("Firebase/App Error:", error);
                    return "An unexpected error occurred. Check the console for more details.";
            }
        }
        
        // --- Authentication Form Setup ---
        // This function dynamically sets up the login/signup forms and their handlers.
        // It needs access to openModal and closeModal, which are defined in the module scope.
        function setupAuthForms(container, onAuthSuccess) {
            // Clear previous content and clone the template for the auth forms.
            container.innerHTML = ''; // Clear previous content if any
            const template = document.getElementById('account-modal-content');
            const content = template.content.cloneNode(true); // Clone the template content
            container.appendChild(content); // Append the cloned content to the container

            // Get references to key elements within the auth form container.
            const toggleBtns = container.querySelectorAll('.toggle-btn');
            const signupForm = container.querySelector('[data-form="signup"]');
            const loginForm = container.querySelector('[data-form="login"]');
            const googleBtnContainer = container.querySelector('.google-signin-btn-container');

            // Create and append the custom Google Sign-In button.
            const googleBtn = document.createElement('button');
            googleBtn.type = 'button'; // Important: prevent form submission on click
            googleBtn.className = 'google-btn-custom';
            // SVG for Google logo and text
            googleBtn.innerHTML = `<svg viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l3.66-2.84z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 6.93l3.66 2.84c.87-2.6 3.3-4.39 6.16-4.39z"/><path fill="none" d="M1 1h22v22H1z"/></svg><span>Sign in with Google</span>`;
            if(googleBtnContainer) googleBtnContainer.appendChild(googleBtn); // Add button to its container
            
            // Handle toggling between signup and login forms.
            toggleBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    toggleBtns.forEach(b => b.classList.remove('active')); // Remove active class from all buttons
                    btn.classList.add('active'); // Add active class to clicked button
                    const showSignup = btn.dataset.tab === 'signup'; // Determine which form to show
                    signupForm.style.display = showSignup ? 'block' : 'none'; // Show/hide signup form
                    loginForm.style.display = showSignup ? 'none' : 'block'; // Show/hide login form
                });
            });

            // Handle sign-up form submission.
            signupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const username = signupForm.querySelector('.signup-username').value.trim().toLowerCase();
                const email = signupForm.querySelector('.signup-email').value;
                const password = signupForm.querySelector('.signup-password').value;
                const errorEl = signupForm.querySelector('.signup-error');
                errorEl.textContent = ''; // Clear previous errors

                try {
                    // Check if the chosen username is already taken.
                    const usernamesRef = window.firebaseSDK.doc(db, "usernames", username);
                    const usernameSnap = await window.firebaseSDK.getDoc(usernamesRef);
                    if (usernameSnap.exists()) {
                        throw new Error('This username is already taken.');
                    }

                    // Create the user account in Firebase Authentication.
                    const userCredential = await window.firebaseSDK.createUserWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user; // Get the newly created user object

                    // Use a batch write to create the username entry and the user's document in Firestore simultaneously.
                    const batch = window.firebaseSDK.writeBatch(db);
                    batch.set(usernamesRef, { userId: user.uid }); // Link username to user UID
                    const userDocRef = window.firebaseSDK.doc(db, "users", user.uid);
                    batch.set(userDocRef, { username, email, friends: [], friendRequests: [] }); // Initialize user document
                    await batch.commit(); // Execute the batch

                    onAuthSuccess(); // Call success callback (which is usually empty here as onAuthStateChanged handles redirection)
                } catch (error) {
                    errorEl.textContent = error.message || getCoolErrorMessage(error); // Display error message
                }
            });

            // Handle login form submission.
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const emailOrUsername = loginForm.querySelector('.login-email').value;
                const password = loginForm.querySelector('.login-password').value;
                const errorEl = loginForm.querySelector('.login-error');
                errorEl.textContent = ''; // Clear previous errors
                
                let emailToLogin = emailOrUsername; // Assume input is an email initially
                try {
                    // Check if the input looks like a username (doesn't contain '@').
                    if (!emailOrUsername.includes('@')) {
                        // If it's likely a username, look it up in the 'usernames' collection.
                        const usernamesRef = window.firebaseSDK.doc(db, "usernames", emailOrUsername.toLowerCase());
                        const usernameSnap = await window.firebaseSDK.getDoc(usernamesRef);
                        if (usernameSnap.exists()) { // If username found
                            const targetUserId = usernameSnap.data().userId;
                            const userDocRef = window.firebaseSDK.doc(db, "users", targetUserId);
                            const userDocSnap = await window.firebaseSDK.getDoc(userDocRef);
                            if(userDocSnap.exists()) {
                               emailToLogin = userDocSnap.data().email; // Use the associated email for login
                            } else { throw new Error("User data not found for this username."); } // Handle case where username exists but user doc doesn't
                        } else { throw { code: 'auth/user-not-found' }; } // Throw error if username doesn't exist
                    }
                    // Attempt to sign in using email and password.
                    await window.firebaseSDK.signInWithEmailAndPassword(auth, emailToLogin, password);
                    onAuthSuccess(); // Call success callback
                } catch (error) {
                    errorEl.textContent = getCoolErrorMessage(error); // Display error message
                }
            });

            // Handle Google Sign-In button click.
            if(googleBtn) {
                googleBtn.addEventListener('click', async () => {
                    const provider = new window.firebaseSDK.GoogleAuthProvider(); // Create Google Auth Provider
                    try {
                        openModal(googleLoaderModal); // Show the loading modal (using module-scoped function)
                        await window.firebaseSDK.signInWithPopup(auth, provider); // Trigger the Google sign-in popup
                        // onAuthStateChanged listener will handle redirection and UI updates after successful sign-in.
                        onAuthSuccess(); 
                    } catch (error) {
                        console.error("Google Sign-In Error: ", error);
                        // Display error message in the login form.
                        const errorEl = loginForm.querySelector('.login-error'); 
                        errorEl.textContent = getCoolErrorMessage(error);
                    } finally {
                        closeModal(googleLoaderModal); // Hide loading modal (using module-scoped function)
                    }
                });
            }
        }

        // --- GUEST DATA MERGING ---
        /**
         * Merges guest data from local storage with existing cloud data.
         * This is called when a guest logs in or signs up.
         * @param {object} cloudData - The existing data from Firestore.
         * @returns {object} - The merged data object.
         */
        function mergeGuestDataWithCloud(cloudData = {}) {
            const guestDataString = localStorage.getItem('anonymousUserData');
            if (!guestDataString) return cloudData; // Return cloud data if no guest data exists

            try {
                const guestData = JSON.parse(guestDataString);
                const mergedData = JSON.parse(JSON.stringify(cloudData)); // Deep clone cloud data

                // Helper function to merge task arrays, avoiding duplicate tasks based on text.
                const mergeTasks = (cloudTasks = [], guestTasks = []) => {
                    const existingTexts = new Set(cloudTasks.map(t => t.text)); // Get texts of existing tasks
                    // Filter guest tasks to include only those not already present in cloud tasks.
                    const newTasks = guestTasks.filter(t => !existingTexts.has(t.text)); 
                    return [...cloudTasks, ...newTasks]; // Combine existing and new tasks
                };

                // Merge daily tasks
                mergedData.dailyTasks = mergeTasks(cloudData.dailyTasks, guestData.dailyTasks);
                // Merge standalone main quests
                mergedData.standaloneMainQuests = mergeTasks(cloudData.standaloneMainQuests, guestData.standaloneMainQuests);
                
                // Merge general task groups
                if (guestData.generalTaskGroups) {
                    if (!mergedData.generalTaskGroups) mergedData.generalTaskGroups = []; // Initialize if doesn't exist
                    guestData.generalTaskGroups.forEach(guestGroup => {
                        // Find if a group with the same name already exists in the cloud data.
                        const cloudGroup = mergedData.generalTaskGroups.find(cg => cg.name === guestGroup.name);
                        if (cloudGroup) {
                            // If group exists, merge its tasks.
                            cloudGroup.tasks = mergeTasks(cloudGroup.tasks, guestGroup.tasks);
                        } else {
                            // If group doesn't exist, add it to the merged data.
                            mergedData.generalTaskGroups.push(guestGroup);
                        }
                    });
                }
                
                // Merge player data (XP and Level)
                if (guestData.playerData) {
                    if (!mergedData.playerData) { // If no player data in cloud, use guest data.
                        mergedData.playerData = guestData.playerData;
                    } else {
                        // Combine XP and take the higher level.
                        const newXp = (mergedData.playerData.xp || 0) + (guestData.playerData.xp || 0);
                        const newLevel = Math.max(mergedData.playerData.level || 1, guestData.playerData.level || 1);
                        mergedData.playerData.xp = newXp;
                        mergedData.playerData.level = newLevel;
                    }
                }
                return mergedData; // Return the fully merged data object
            } catch (error) {
                console.error("Failed to merge guest data:", error);
                return cloudData; // Return original cloud data if merging fails
            }
        }
        // =========================================================================
        // END OF INITIALIZATION AND CORE LOGIC
        // =========================================================================


        // --- INITIALIZATION AND RUN ---

        // Main function to load user session data and initialize the UI.
        async function loadUserSession() {
            await initialLoad(); // Load tasks, player data, settings etc.
            await updateUserUI(); // Update UI based on logged-in status
            await promptForUsernameIfNeeded(); // Prompt for username if necessary
            await updateUserUI(); // Update UI again in case username was set
            checkDailyReset(); // Perform daily reset logic
            resumeTimers(); // Ensure timers are running
        }
        
        // One-time initialization tasks that should run when the script loads.
        const initOnce = () => {
            // Add listener for system theme changes using matchMedia API.
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applySettings);
            showRandomQuote(); // Display a random quote in the header.
            // Set interval to check for overdue tasks periodically (e.g., every minute).
            setInterval(checkOverdueTasks, 60 * 1000); 
        };

        // Execute one-time initializations first.
        initOnce(); 
        // Then, load the user's session data and finalize the app setup.
        await loadUserSession(); 

        // Return the app controller object. This object is stored in `appController` 
        // and provides methods to manage the app's state (like shutdown or updating user).
        return {
            isPartial: false, // Indicates full initialization has occurred.
            // shutdown function to clean up listeners and intervals when the app is unloaded or user logs out.
            shutdown: () => {
                 Object.keys(activeTimers).forEach(id => clearInterval(activeTimers[id])); // Clear all active timers
                 if (unsubscribeFromFirestore) unsubscribeFromFirestore(); // Clean up Firestore listener
                 if (unsubscribeFromFriends) unsubscribeFromFriends(); // Clean up friends listener
            },
            // updateUser function to re-initialize the app logic when the user state changes (e.g., login/logout).
            updateUser: async (newUser) => {
                user = newUser; // Update the internal user reference
                await loadUserSession(); // Reload session data based on the new user state
            }
        };
        // Note: The return value of initializeAppLogic is assigned to `appController` in the `onAuthStateChanged` callback.
    } // End of initializeAppLogic function
    </script>
</body>
</html>